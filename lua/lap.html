<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
LAP: Lua Asynchronous Protocol
<br>
Lua has one of the coolest yet most underutilized asynchronous programming
tools: the <span class=code>coroutine</span> module, specifically <span class=code>coroutine.yield</span>. Lua's <span class=code>yield</span>
can be called from any depth, resuming execution at the callsite upon
<span class=code>coroutine.resume</span>. This means that if we swap out traditionally blocking APIs
like <span class=code>file:read</span> with ones that are non-blocking and yielding (i.e. by running
IO in a separate thread or using unix's <span class=code>aio</span> interface) we use most libraries
asynchronously without changing a single line of code.
<br>
<div class=info>For an example of implementing the LAP protocol see <a href="#Package_fd">#Package_fd</a></div>
<br>
LAP is a lightweight zero-dependency asynchronous protocol which aims to take
advantage of Lua's awesomeness. It is architected to allow libraries to provide
a lightweight "asynchronous mode" so that they can be used asynchronously by a
coroutine executor. This allows users and library authors to write code that
looks synchronous but which can be executed asynchronously at the application
author's discression.
<br>
This folder also contains the <span class=code>lap.lua</span> library, see the Library section.
Library authors <b>do not</b> need to depend on this library to work with the LAP
protocol.
<br>
The LAP protocol has two components: <ul>
  <li>yielding protocol: An ultra simple yet optionally-performant to communicate
  with the executor loop (example: see <span class=code>lap.Lap</span>)</li>
  <li>two global tables which libraries can use to schedule coroutines (<span class=code>LAP_READY</span>)
  and register their asynchronous API (<span class=code>LAP_FNS_ASYNC</span> and <span class=code>LAP_FNS_SYNC</span>)</li>
</ul>
Library authors can fully support the protocol by following the
Yielding Protocol below and copy/pasting the following:
<div class=code-block>LAP_FNS_SYNC &nbsp;= LAP_FNS_SYNC &nbsp;or {}<br>
LAP_FNS_ASYNC = LAP_FNS_ASYNC or {}<br>
<br>
// register functions to switch modes, see end of lap.lua for example<br>
table.insert(LAP_FNS_SYNC, &nbsp;function() ... end)<br>
table.insert(LAP_FNS_ASYNC, function() ... end)<br>
<br>
// implement your asynchronous functions by following the protocol.
</div>
<br>
Library authors should make their default API <b>synchronous</b> (blocking) by
default, except for items that cannot be used synchronously.
<br>
<h3><span class=code>LAP_READY</span> Global Table</h3>
<span class=code>LAP_READY</span> is a global key/value table where the keys are the coroutines which
should be run at some later time (by the executor). The values are arbitrary
(typically a string identifier for debugging).
<br>
This means that a coroutine can schedule another coroutine <span class=code>cor</span> by simply doing
<span class=code>LAP_READY[cor</span> = "my_identifier"
</div></body>
</html>
