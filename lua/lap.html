<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
LAP: Lua Asynchronous Protocol
<p>
Lua has one of the coolest yet most underutilized asynchronous programming
tools: the <span class=code>coroutine</span> module, specifically <span class=code>coroutine.yield</span>. Lua's <span class=code>yield</span>
can be called from any depth, resuming execution at the callsite upon
<span class=code>coroutine.resume</span>. This means that if we swap out traditionally blocking APIs
like <span class=code>file:read</span> with ones that are non-blocking and yielding (i.e. by running
IO in a separate thread or using unix's <span class=code>aio</span> interface) we use most libraries
asynchronously without changing a single line of code.
<p>
<div class=info>For an example of implementing the LAP protocol see <a href="#Package_fd">#Package_fd</a></div>
<p>
LAP is a lightweight zero-dependency asynchronous protocol which aims to take
advantage of Lua's awesomeness. It is architected to allow libraries to provide
a lightweight "asynchronous mode" so that they can be used asynchronously by a
coroutine executor. This allows users and library authors to write code that
looks synchronous but which can be executed asynchronously at the application
author's discression.
<p>
This folder also contains the <span class=code>lap.lua</span> library, see the Library section.
Library authors <b>do not</b> need to depend on this library to work with the LAP
protocol.
<p>
The LAP protocol has two components: <ul>
  <li>yielding protocol: An ultra simple yet optionally-performant to communicate
  with the executor loop (example: see <span class=code>lap.Lap</span>)</li>
  <li>two global tables which libraries can use to schedule coroutines (<span class=code>LAP_READY</span>)
  and register their asynchronous API (<span class=code>LAP_FNS_ASYNC</span> and <span class=code>LAP_FNS_SYNC</span>)</li>
</ul>
Library authors can fully support the protocol by following the
Yielding Protocol below and copy/pasting the following:
<div class=code-block>LAP_FNS_SYNC &nbsp;= LAP_FNS_SYNC &nbsp;or {}<br>
LAP_FNS_ASYNC = LAP_FNS_ASYNC or {}<br>
<br>
// register functions to switch modes, see end of lap.lua for example<br>
table.insert(LAP_FNS_SYNC, &nbsp;function() ... end)<br>
table.insert(LAP_FNS_ASYNC, function() ... end)<br>
<br>
// implement your asynchronous functions by following the protocol.
</div>
<p>
Library authors should make their default API <b>synchronous</b> (blocking) by
default, except for items that cannot be used synchronously.
<p>
<h3><span class=code>LAP_READY</span> Global Table</h3>
<span class=code>LAP_READY</span> is a global key/value table where the keys are the coroutines which
should be run at some later time (by the executor). The values are arbitrary
(typically a string identifier for debugging).
<p>
This means that a coroutine can schedule another coroutine <span class=code>cor</span> by simply doing
<span class=code>LAP_READY[cor] = "my_identifier"</span>. This simple feature can be used for many
purposes such as creating Channel datastructures as well as handling any/all
behavior. See the Library section for details.
<p>
<h3><a id="lap-protocol" href="#lap-protocol">Yielding Protocol</h3></a>
LAP's yielding protocol makes it trivial for Lua libraries to interface with
executors. Libraries can simply call <span class=code>coroutine.yield</span> with one of the
following and a compliant executor will perform the behavior specified if it is
supported (else it will run the coroutine on the next loop). <ul>
  <li><span class=code>yield(nil)</span> or <span class=code>yield(false)</span>: forget the coroutine, the executor will not
  run it.</li>
  <li><span class=code>yield(true)</span>: run the corroutine again as soon as possible. <ul>
    <li>Should prevent the executor loop from sleeping.</li>
    <li>Equivalent to: <span class=code>LAP_READY[coroutine.running()] = true; coroutine.yield()</span></li>
  </ul></li>
  <li><span class=code>yield("sleep", sleepSec)</span>: run the coroutine again after <span class=code>sleepSec</span> seconds
  (a float).</li>
  <li><span class=code>yield("poll", fileno, events)</span>: tell the coroutine to use unix's
  <span class=code>poll(fileno, events)</span> syscall to determine when ready.</li>
  <li>Other yield values may be defined by application-specific executors.
  If the executor doesn't recognize a value it can either throw an error or
  treat it as <span class=code>true</span> (aka "ready"), depending on the application requirements.</li>
</ul>
<p>
<h4><a id="lap-globals" href="#lap-globals">Global Variables</h4></a>
<p>
There are four global variables defined by the LAP protocol: <ul>
  <li><span class=code>LAP_READY</span>: contains the currently ready coroutines for the executor loop to
  resume.</li>
  <li><span class=code>LAP_FNS_SYNC</span> / <span class=code>LAP_FNS_ASYNC</span>: contains functions to switch lua to synchronous /
  asynchronous modes, respectively.</li>
  <li><span class=code>LAP_ASYNC</span>: is set to true when in async mode to determine behavior at
  runtime.</li>
</ul>
<p>
The sync/async tables allows a user to write code in a blocking style yet it
can be run asynchronously, such as the following. You can even switch back and
forth so that tests can be run in both modes.
<p>
<div class=code-block>function getLines(path, fn)<br>
&nbsp; local lines = {}<br>
&nbsp; for line in io.lines(path) do<br>
&nbsp; &nbsp; table.insert(lines, line)<br>
&nbsp; end<br>
&nbsp; return lines<br>
end
</div>
<p>
<div class=info>Recomendation: use <a href="#lap.async">#lap.async</a> and <a href="#lap.sync">#lap.sync</a> to switch modes</div>
<p>
<h3><span class=code>lap.lua</span> Library</h3>
The (pure lua) <a href="#lap">#lap</a> library implements: <ul>
  <li><a href="#lap.Lap">#lap.Lap</a> default implementation of a single loop (aka "lap") in an
  executor.</li>
  <li><a href="#lap.Any">#lap.Any</a> and <a href="lap.all">lap.all</a> for interacting with lists of coroutines.</li>
  <li><a href="#lap.channel()">#lap.channel()</a> which creates the <a href="#lap.Recv">#lap.Recv</a> and <a href="#lap.Send">#lap.Send</a> channel types to send
  values between coroutines.</li>
  <li><a href="#lap.async">#lap.async</a> / <a href="#lap.sync">#lap.sync</a>: switches all registered libraries to
  async/sync mode (just calls every function in <a href="#lap.LAP_FNS_SYNC">#lap.LAP_FNS_SYNC</a> or
  <a href="#LAP_FNS_ASYNC">#LAP_FNS_ASYNC</a>)</li>
</ul>
<p>
<h1><a id=""lap"" href="#"lap"">Mod lap</h1></a>
superpower your libraries run either sync or async
<p>
<b>Types</b> <ul>
  <li><b>lap.Recv</b></li>
  <li><b>lap.Send</b></li>
  <li><b>lap.Any</b></li>
  <li><b>lap.Lap</b></li>
</ul>
<p>
<b>Functions</b> <ul>
  <li><span class=code>reset()</span>
  Clear all lap globals.</li>
  <li><span class=code>formatCorErrors(corErrors)</span></li>
  <li><span class=code>sync()</span>
  Switch lua to synchronous mode</li>
  <li><span class=code>async()</span>
  Switch lua to asynchronous (yielding) mode</li>
  <li><span class=code>lt1(a, b) -&gt; a[1] &lt; b[1]</span></li>
  <li><span class=code>yield(lap, fns, setup, teardown)</span></li>
  <li><span class=code>all(lap, fns, setup, teardown)</span></li>
  <li><span class=code>schedule(lap, fns, setup, teardown)</span></li>
</ul>
<p>
<h2><a id=""lap.Recv"" href="#"lap.Recv"">Record Recv</h2></a>
<ul>
  <li><b>deq</b> </li>
  <li><b>cor</b> </li>
</ul>
<span class=code>Recv() -&gt; recv</span> the receive side of channel.
<p>
Is considered closed when all senders are closed.
<p>
Notes: <ul>
  <li>Use <span class=code>recv:sender()</span> to create a sender. You can create
  multiple senders.</li>
  <li>Use <span class=code>recv:recv()</span> or simply <span class=code>recv()</span> to receive a value
  (or block)</li>
  <li>User <span class=code>sender:send(v)</span> or simply <span class=code>sender(v)</span> to send a value.</li>
  <li><span class=code>recv:close()</span> when done. Also closes all senders.</li>
  <li><span class=code>#recv</span> gets number of items buffered.</li>
  <li><span class=code>recv:isDone()</span> returns true when either recv is closed
  OR all senders are closed and <span class=code>#recv == 0</span></li>
</ul>
<p>
<h2><a id=""lap.Send"" href="#"lap.Send"">Record Send</h2></a>
Sender, created through <span class=code>recv:sender()</span>
Is considered closed if the receiver is closed.  The receiver will
automatically close if it is garbage collected.
<p>
<h2><a id=""lap.Any"" href="#"lap.Any"">Record Any</h2></a>
<ul>
  <li><b>cor</b> </li>
  <li><b>fns</b> </li>
  <li><b>done</b> </li>
</ul>
<p>
<h2><a id=""lap.Lap"" href="#"lap.Lap"">Record Lap</h2></a>
<ul>
  <li><b>sleepFn</b> </li>
  <li><b>monoFn</b> </li>
  <li><b>monoHeap</b> </li>
  <li><b>defaultSleep</b> </li>
  <li><b>pollMap</b> </li>
  <li><b>pollList</b> :
  Poll list data structure. Required methods:</li>
  <li>__len                   to get length with `#`</li>
  <li>insert(fileno, events)  insert the fileno+events into the poll list</li>
  <li>remove(fileno)          remove the fileno from poll list</li>
  <li>ready(self, durationSec) -> {filenos}
  poll for durationSec (float), return any ready filenos.</li>
</ul>
A single lap of the executor loop
<p>
Example <div class=code-block>&nbsp; -- schedule your main fn, which may schedule other fns<br>
&nbsp; lap.schedule(myMainFn)<br>
<br>
&nbsp; -- create a Lap instance with the necessary configs<br>
&nbsp; local Lap = lap.Lap{<br>
&nbsp; &nbsp; sleepFn=civix.sleep, monoFn=civix.monoSecs, pollList=fd.PollList()<br>
&nbsp; }<br>
<br>
&nbsp; -- run repeatedly while there are coroutines to run<br>
&nbsp; while next(LAP_READY) do<br>
&nbsp; &nbsp; errors = Lap(); if errors then<br>
&nbsp; &nbsp; &nbsp; -- handle errors<br>
&nbsp; &nbsp; end<br>
&nbsp; &nbsp; -- do other things in your application's executor loop<br>
&nbsp; end
</div>
<p>
</div></body>
</html>
