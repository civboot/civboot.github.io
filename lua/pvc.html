<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<span class=code>pvc &lt;cmd&gt;</span>: patch version control command line utility.
<p>
<div class=info>NOTICE: pvc now works but will have bugs and the API is subject to change.
Use at your own risk and always back up work that you are using pvc
to track (aka use <a href="#pvc-git">git and pvc together</a>).
</div>
<p>
<h3><a id="pvc-install" href="#pvc-install">Installation</h3></a>
<p>
Simply follow civlua's <a href="#Installation">#Installation</a> and add the following to your <span class=code>.bashrc</span>
<div class=code-block>alias pvc="civlua pvc"</div>
<p>
<h2><a id="pvc-about" href="#pvc-about">About</h2></a>
<b>pvc</b> is a version control system similar to git or mercurial, but is ultra
simple: branches are simply a <span class=code>base</span> followed by a set of unix patches with
incrementing id. The only fundamental disadvantage (or advantage) of using pvc
instead of git is that pvc supports only fast-forward merges, which are the
cleanest and simplest to understand.
<p>
Builtin cmds:<ul>
  <li><span class=code>init dir</span>: initialize the <span class=code>dir</span> (default=CWD) for PVC.</li>
  <li><span class=code>diff branch1 branch2</span>: get the difference (aka the patch) between
  <span class=code>branch1</span> (default=<span class=code>at</span>) and <span class=code>branch2</span> (default=local). Each value can be
  either a branch name or a directory which contains a <span class=code>.pvcpaths</span> file.
  <p>
  <div class=info>See <b>Usage</b> for how this can be used for the first commit.</div></li>
  <li><span class=code>commit</span>: add changes to the current branch as a patch and move <span class=code>at</span>
  forward. The commit message can be written to the COMMIT file or be
  specified after the <span class=code>--</span> argument (multiple are space-separated).</li>
  <li><span class=code>at [branch]</span>: if <span class=code>branch</span> is empty then return the active
  <span class=code>branch#id</span>.
  <p>
  If <span class=code>branch</span> is set then this sets the active <span class=code>branch#id</span>, causing the
  local directory to be updated (default id=tip).
  <div class=info>git equivalent: <span class=code>checkout</span></div></li>
  <li><span class=code>tip [branch]</span>: get the highest id for branch (default=current).</li>
  <li><span class=code>branch name [from]</span>: start a new branch of name <span class=code>name</span>. The optional
  <span class=code>from</span> (default=<span class=code>at</span>) argument can specify a local <span class=code>branch#id</span> or an
  (external) <span class=code>path/to/dir</span> to graft onto the pvc tree.
  <p>
  <div class=info>the <span class=code>from/dir</span> is commonly used by maintainers to accept patches from
  contributors.
  </div></li>
  <li><span class=code>rebase [branch [id]]</span>: change the base of branch to id.
  (default branch=current, id=branch base's tip)</li>
  <li><span class=code>grow from</span>: copy the commits at <span class=code>from</span> onto current branch.
  The base of <span class=code>from</span> must be the current branch's tip.
  Then move the branch to backup.
  <div class=info>in git this is a "fast forward" merge</div></li>
  <li><span class=code>pvc show [branch#id] --num=10 --full</span>
  <p>
  If no branch is specified: show branches. <span class=code>full</span> also displays
  the base and tip.
  <p>
  Else show branch#id and the previous <span class=code>num</span> commit messages.
  With <span class=code>full</span> show the full commit message, else show only
  the first line.</li>
  <li><span class=code>pvc desc branch [$path/to/new]</span>
  get or set the description for a single branch id.
  The default branch is <span class=code>at</span>.
  <p>
  The new description can be passed via <span class=code>path/to/new</span> or
  after <span class=code>--</span> (like commit).</li>
  <li><span class=code>pvc squash [branch#id endId]</span>
  squash branch id -> endId (inclusive) into a single patch at <span class=code>id</span>.
  <p>
  You can then edit the description by using <span class=code>pvc desc branch#id</span>.</li>
  <li><span class=code>export path/ [branch]</span>: (warning: untested)
  copy all patch files in the branch directory to
  <span class=code>path/</span>. If an <span class=code>#id</span> is specified then it is used as the maximum id
  (defaults: branch=current, id=tip)
  <p>
  <div class=info>the resulting directory is commonly sent to <span class=code>tar -zcvf branch.tar.gz path/</span>
  and then <span class=code>branch.tar.gz</span> sent to a maintainer to be merged
  </div></li>
  <li><span class=code>prune branch id</span>: (warning: untested) remove a branch by moving it to a
  backup directory. If an id is given then instead move ids from <span class=code>[id,tip]</span>
  (inclusive) to a backup.</li>
</ul>
<p>
<h2><a id="pvc-init" href="#pvc-init">Initiaize your pvc repo</h2></a>
<div class=info>You may also want to see <a href="#pvc-git">#pvc-git</a> to use git for backups</div>
<p>
First install <a href="#Package_civ">#Package_civ</a>, then run pvc in bash with <span class=code>civ.lua pvc &lt;cmd&gt;</span>.
<p>
To track an existing directory:<ul>
  <li><span class=code>cd path/to/dir</span> to navigate to the directory</li>
  <li><span class=code>pvc init</span> to initialize pvc</li>
  <li><span class=code>pvc diff</span> prints the diff of local changes to stderr and untracked files
  (that are not matched in <span class=code>.pvcignore</span> to stdout. Edit <span class=code>.pvcignore</span>
  with appropriate entries (see <a href="#pvcignore">#pvcignore</a>) to ignore paths you don't
  want tracked until <span class=code>pvc diff</span> shows only files you want tracked.
  <p>
  When ready, running <span class=code>pvc diff &gt;&gt; .pvcpaths</span> in bash will track all untracked
  files.
  <div class=info>Alternatively, manually add files to <span class=code>.pvcpaths</span></div></li>
  <li><span class=code>pvc commit -- initial pvc commit</span> will commit your changes to
  <span class=code>.pvc/main/commit/.../1.p</span>.</li>
</ul>
<p>
<h3><a id="pvcignore" href="#pvcignore">pvcignore</h3></a>
The <span class=code>.pvcignore</span> file should contain a line-separated list of <a href="#string.find">#string.find</a>
patterns that should be ignored. Items ending in <span class=code>/</span> will apply to whole
directories. A common pvc ignore file might look like:
<p>
<div class=code-block># directories<br>
%.git/<br>
%.out/<br>
<br>
# extensions<br>
%.so$<br>
<br>
# binary files<br>
%./path/to/some_binary
</div>
<p>
<h3><a id="pvc-git" href="#pvc-git">Use with git</h3></a>
pvc is still in early development, so there is no hosting service which
ergonomically supports backing-up development. The following is how pvc
(and civlua) itself is developed and seems to work well.
<p>
Basically, we are going to have two git repositories. I will use
civlua as the example:<ul>
  <li><a href="https://github.com/civboot/civlua">https://github.com/civboot/civlua</a>: your "main" one that hosts your released
  versions and documentation. This should NOT contain any <span class=code>.pvc/</span> files (but
  should contain i.e.  <span class=code>.pvcpaths</span>).</li>
  <li><a href="https://github.com/vitiral/civlua.pvc/commits/main/">https://github.com/vitiral/civlua.pvc/commits/main/</a>: is literally the git
  repository for your <span class=code>.pvc/</span> directory. While developing we can push
  commits/branches/whatever here.</li>
</ul>
<p>
<b>First</b>, put <span class=code>.pvc/</span> in your main repo's <span class=code>.gitignore</span>
<div class=code-block>echo .pvc &gt;&gt; .gitignore</div>
<p>
<b>Second</b>, follow the <a href="#pvc-init">#pvc-init</a> section above. This should include adding
all your files to pvc and making your first pvc commit.
<p>
<b>Third</b>, <span class=code>cd .pvc/</span> and create your git repository <i>inside the .pvc/
directory</i>. This will literally track your patch files themselves. Use the
following as your <span class=code>.pvc/.gitignore</span>. You may also want to add a <span class=code>README.md</span>
directing folks to your main git repo.
<div class=code-block># .pvc/.gitignore<br>
**/*.snap/<br>
backup/
</div>
<p>
Finally, add the following to your <span class=code>.bashrc</span>
<div class=code-block># Note: you must also have pvc aliased<br>
function pvcp() {<br>
&nbsp; desc="$(pvc at): $(pvc desc --full)"<br>
&nbsp; (cd .pvc/ &amp;&amp;<br>
&nbsp; &nbsp; git add ./ &amp;&amp;<br>
&nbsp; &nbsp; git commit -am "$desc" &amp;&amp;<br>
&nbsp; &nbsp; git push origin main)<br>
}
</div>
<p>
Now you can hack using <span class=code>pvc commit</span> etc and push to your <span class=code>repo.pvc</span> by
simply calling <span class=code>pvcp</span>. Your git commit log will be your current <span class=code>at</span>
location followed by the commit message. When you want to push your
documentation or releases to git, simply do so -- your main commit log
won't be polluted by commiting pvc files.
<p>
<h1><a id="pvc-arch" href="#pvc-arch">Architecture</h1></a>
<p>
This architecture is given both so users can debug or fix any errors as well as
to make it easier to create other implementations of pvc (i.e. in bash).
<p>
pvc is composed of the following components: <ul>
  <li><b>repo</b>: the pvc repo (repository) is stored in the <span class=code>.pvc/</span> directory inside of
  a <b>project</b>. It contains directories (which are the branches) and the plaintext file
  <span class=code>at</span> which defines the "current commit" as a <b>commit reference</b> (i.e. <span class=code>branch#123</span>).
  Additionally it contains: <ul>
    <li><span class=code>backup/</span> directory, which contain <span class=code>name-&lt;epochsec&gt;/</span> directories for backups. In
    general, pvc should not delete things but should instead move things to a backup
    directory, reporting these operations to the user (and possibly a log file as well).</li>
  </ul></li>
  <li><b>pvcpaths</b> is the project-local <span class=code>.pvcpaths</span> file which contains a
  newline-separated list of project-relative paths.  This is used by pvc to
  determine which paths are tracked. It's contents are tracked as a normal file
  (it is included in the patch diff).</li>
  <li><b>branch</b>: a branch is a directory inside the repo (i.e. <span class=code>.pvc/main/</span>). It
  contains the <span class=code>commit/</span> directory (described in <b>commit</b>) and the plain-text files:
  <ul>
    <li><b>base</b>: contains <span class=code>branch#123</span>. This file is not present if the branch is
    the trunk.</li>
    <li><b>tip</b>: contains an ascii decimal number, representing the last commit id.</li>
  </ul></li>
  <li><b>branch (action)</b>: to "create a branch" means to create a new directory
  inside <span class=code>.pvc/</span> and initialize it with the proper <span class=code>base</span> and <span class=code>tip</span> files.
  The base branch must already exist.</li>
  <li><b>commit (noun)</b>: refers to a single patch file (i.e. <span class=code>.pvc/branch/commit/.../123.p</span>). <ul>
    <li>The length of <span class=code>commit/.../</span> is stored in <span class=code>commit/depth</span> which is an ascii
    decimal number, always divisible by 2. Each sub-directory has exactly two
    digits. For instance, a depth of 4 would store <span class=code>12.p</span> in
    <span class=code>commit/00/00/12.p</span> and store <span class=code>123456.p</span> in <span class=code>12/34/123456.p</span>.</li>
    <li><b>description</b>: the top of the patch file (before the first unidiff)
    contains a plain-text description of the commit.</li>
    <li><b>diffs</b>: the rest of the patch file contains a series of file differences
    from the previous patch version in the <a href="https://en.wikipedia.org/wiki/Diff#Unified_format">unidiff</a> (aka <span class=code>diff -u</span>) format.</li>
    <li><b>commit</b> is often shorthand for the <span class=code>commit reference</span> (i.e.
    <span class=code>branch#123</span>), which refers uniquely to a specific branch and patch file
    or snapshot directory.</li>
  </ul></li>
  <li><b>commit (action)</b>: "making a commit" means to take the difference of the
  current directory and store it as a patch file in the branch's <span class=code>commit/</span>
  directory.</li>
  <li><b>snapshot</b>: a snapshot is the local directory state at a specific commit. It
  is a directory which uses the extension <span class=code>.snap/</span> inside of the <span class=code>commit/</span>
  directory, i.e. <span class=code>commit/00/123.snap/</span>.</li>
  <li><b>checkout (action)</b>: to "checkout a commit" means to make the local project
  directory the same as the commit. This is performed by finding the closest
  <b>snapshot</b> and applying commit patches (either forwards or backwards) in
  order to make the snapshot reflect the commits state.</li>
  <li><b>rebase (action)</b>: to "rebase a branch" means to increase the id of it's
  <b>base</b>. This is accomplished by making a copy of the new id's snapshot and
  repeatedly applying the unix <span class=code>merge</span> command (or equivalent) on each change,
  using the copied snapshot as <span class=code>to</span> and incrementing the <span class=code>base</span> along the
  change patches. Each new <span class=code>patch</span> file should be stored, incrementing from
  the base. <ul>
    <li>the software should detect if conflicts are unresolveable and exit, telling the
    user how to fix them. The software should be able to resume the rebase once
    the conflicts are resolved.</li>
    <li>For example, the reference implementation creates a new branch called
    <span class=code>branch__rebase</span> to perform this action. When calling rebase, it first
    checks for this branch and attempts to resume from it. On failure,
    it tells the user where the failing files that need to be fixed are
    located.</li>
    <li>when the rebase is complete, the old branch should be moved to <span class=code>.pvc/backup</span>
    then replaced with the rebased version.</li>
  </ul></li>
  <li><b>merge</b>: merges a branch onto another one. The branch must already be
  rebased to the tip (also called a "fast forward merge"), so this is literally
  just copying the patch files and incrementing the <b>tip</b>.</li>
  <li><b>squash</b>: combines multiple commits into one, moving larger commits down.
  The descriptions should be concatenated, and can be edited separately by the
  user.</li>
  <li><b>export</b>: simply copies a <b>branch</b> without it's snapshot directories to a
  separate directory, which can be sent to a maintainer to be merged.</li>
</ul>
<p>
<h2>Other Operations</h2>
Other operations, such as showing commit messages or ammending a commit, are
not defined explicitly, but you can see the reference implementation for
details. Typically their implementation is either straightforward or can be
performed by variations of the above operations.
<p>
Also, operations which mutate the meaning of a commit (such as squash or
rebase) should check to make sure that no branches depend on the branch being
mutated.
<p>


<p>
<h1><a id=""pvc2"" href="#"pvc2"">Mod pvc2</h1></a>
<p>
<b>Types</b> <ul>
  <li><b>pvc2.Diff</b></li>
  <li><b>pvc2.main</b></li>
</ul>
<p>
<b>Functions</b> <ul>
  <li><span class=code>backupId() -&gt; tostring(ix.epoch():asSeconds())</span>
  this exists for tests to override</li>
  <li><span class=code>patchPost(dir, patch, reverse)</span>
  Given a patch string perform post-patch requirements in dir.
  
  These must be given near the top of the patch file, before the first
  <span class=code>---</span>.  Supported commands (arguments are actually tab separated):
  <div class=code-block>! rename before &nbsp;after<br>
! swap &nbsp; first &nbsp; second
</div>
  
  If reverse is given it does the opposite; also this should be called BEFORE
  calling <span class=code>patch(reverse=true)</span></li>
  <li><span class=code>patch(P, br1, br2) -&gt; string, s1, s2</span>
  Create a patch file from two branch arguments (see resolve2).</li>
  <li><span class=code>rpatch(dir, diff)</span>
  reverse patch, applying diff to dir</li>
  <li><span class=code>calcPatchDepth(id)</span>
  calculate necessary directory depth.
  Example: 01/23/12345.p has dirDepth=4</li>
  <li><span class=code>branchDir(P, branch, dot)</span>
  return the branch path in project regardless of whether it exists</li>
  <li><span class=code>getbase(bdir, br) -&gt; br, id</span></li>
  <li><span class=code>rawtip(bdir, id)</span></li>
  <li><span class=code>depth(bdir) -&gt; readInt(toDir(bdir)..'commit/depth')</span></li>
  <li><span class=code>patchPath(bdir, id, last, depth) -&gt; string?</span></li>
  <li><span class=code>snapDir(bdir, id) -&gt; string?</span>
  Get the snap/ path regardless of whether it exists</li>
  <li><span class=code>snapshot(P, br,id) -&gt; .../id.snap/</span>
  Snapshot the branch#id by applying patches.
  Return the snapshot directory</li>
  <li><span class=code>deepen(bdir)</span>
  increase the depth of branch by 2, adding a <span class=code>00/</span> directory.</li>
  <li><span class=code>parseBranch(str, bdefault, idefault) -&gt; branch, id</span></li>
  <li><span class=code>rawat(P, branch, id)</span>
  get or hard set the current branch/id</li>
  <li><span class=code>at(P, nbr,nid)</span>
  get or set where the working id is at.</li>
  <li><span class=code>pathsUpdate(P, add, rm)</span>
  update paths file (path) with the added and removed items</li>
  <li><span class=code>resolve(P, branch) -&gt; br, id, bdir</span>
  resolve a branch name. It can be one of: <ul>
    <li>A directory with <span class=code>/</span> in it.</li>
    <li><span class=code>branch</span> or <span class=code>branch#id</span></li>
    <li>Special: at</li>
  </ul></li>
  <li><span class=code>resolveSnap(P, branch) -&gt; snap/, br, id, bdir</span>
  resolve and take snapshot, permits local</li>
  <li><span class=code>resolve2(P, br1, br2) -&gt; branch1/ branch2/</span>
  resolve two branches into their branch directories. Defaults:<ul>
    <li>br1 = 'at'</li>
    <li>br2 = 'local'</li>
  </ul></li>
  <li><span class=code>diff(P, branch1, branch2) -&gt; Diff</span></li>
  <li><span class=code>init(P, branch)</span></li>
  <li><span class=code>commit(P, desc) -&gt; snap/, id</span></li>
  <li><span class=code>nameId(P, branch,id) -&gt; br,id</span>
  get the conventional brName, id for a branch,id pair</li>
  <li><span class=code>branch(P, name, fbr,fid) -&gt; bdir, id</span></li>
  <li><span class=code>branches(P) -&gt; list</span>
  get all branches</li>
  <li><span class=code>checkBranch(P, name, checks, dir)</span></li>
  <li><span class=code>graft(P, name, from)</span></li>
  <li><span class=code>merge(tdir, bdir, cdir)</span></li>
  <li><span class=code>backupDir(P, name) -&gt; string</span>
  return a backup directory (uses the timestamp)</li>
  <li><span class=code>rebase(P, branch, id) -&gt; backup/dir/</span>
  rebase the branch (current branch) to make it's baseid=id</li>
  <li><span class=code>grow(P, to, from)</span>
  Grow <span class=code>to</span> by copying patches <span class=code>from</span></li>
  <li><span class=code>desc(ppath, num) -&gt; {string}</span>
  return the description of ppath</li>
  <li><span class=code>squash(P, br, bot,top)</span>
  squash num commits together before br#id.</li>
</ul>
<p>
<h2><a id=""pvc2.Diff"" href="#"pvc2.Diff"">Record Diff</h2></a>
<ul>
  <li><b>dir1</b> </li>
  <li><b>dir2</b> </li>
  <li><b>equal</b> </li>
  <li><b>changed</b> </li>
  <li><b>deleted</b> </li>
  <li><b>created</b> </li>
</ul>
<span class=code>Diff:of(dir1, dir2)</span> returns what changed between two pvc dirs.
<p>
<h2><a id=""pvc.main"" href="#"pvc.main"">Mod pvc.main</h2></a>
<p>
<b>Functions</b> <ul>
  <li><span class=code>help(HELP)</span></li>
  <li><span class=code>init(args) -&gt; nil</span>
  <span class=code>init dir</span>: initialize the <span class=code>dir</span> (default=CWD) for PVC.</li>
  <li><span class=code>diff(args) -&gt; Diff</span>
  <span class=code>diff branch1 branch2 --full</span>: get the difference (aka the patch) between
  <span class=code>branch1</span> (default=<span class=code>at</span>) and <span class=code>branch2</span> (default=local). Each value can be
  either a branch name or a directory which contains a <span class=code>.pvcpaths</span> file.</li>
  <li><span class=code>commit(args)</span>
  <span class=code>commit</span>: add changes to the current branch as a patch and move <span class=code>at</span>
  forward. The commit message can be written to the COMMIT file or be
  specified after the <span class=code>--</span> argument, where multiple arguments are space
  separated.</li>
  <li><span class=code>at(args) -&gt; string</span>
  <span class=code>at [branch]</span>: if <span class=code>branch</span> is empty then return the active
  <span class=code>branch#id</span>.
  
  If <span class=code>branch</span> is set then this sets the active <span class=code>branch#id</span>, causing the
  local directory to be updated (default id=tip).
  <div class=info>git equivalent: <span class=code>checkout</span></div></li>
  <li><span class=code>tip(args) -&gt; string</span>
  <span class=code>tip [branch]</span>: get the highest branch#id for branch (default=at).</li>
  <li><span class=code>branch(args)</span>
  <span class=code>branch name [from]</span>: start a new branch of name <span class=code>name</span>. The optional
  <span class=code>from</span> (default=<span class=code>at</span>) argument can specify a local <span class=code>branch#id</span> or an
  (external) <span class=code>path/to/dir</span> to graft onto the pvc tree.
  
  <div class=info>the <span class=code>from/dir</span> is commonly used by maintainers to accept patches from
  contributors.
  </div></li>
  <li><span class=code>show(args)</span>
  <span class=code>pvc show [branch#id] --num=10 --full</span>
  
  If no branch is specified: show branches. <span class=code>full</span> also displays
  the base and tip.
  
  Else show branch#id and the previous <span class=code>num</span> commit messages.
  With <span class=code>full</span> show the full commit message, else show only
  the first line.</li>
  <li><span class=code>desc(args)</span>
  <span class=code>pvc desc branch [$path/to/new]</span>
  get or set the description for a single branch id.
  The default branch is <span class=code>at</span>.
  
  The new description can be passed via <span class=code>path/to/new</span> or
  after <span class=code>--</span> (like commit).</li>
  <li><span class=code>squash(args)</span>
  <span class=code>pvc squash [branch#id endId]</span>
  squash branch id -> endId (inclusive) into a single patch at <span class=code>id</span>.
  
  You can then edit the description by using <span class=code>pvc desc branch#id</span>.</li>
  <li><span class=code>rebase(args) -&gt; string</span>
  <span class=code>rebase [branch [id]]</span>: change the base of branch to id.
  (default branch=current, id=branch base's tip)</li>
  <li><span class=code>grow(args)</span>
  <span class=code>grow from --to=at</span>: grow <span class=code>to</span> (default=<span class=code>at</span>) using branch from.
  
  <div class=info>In other version control systems this is called a
  "fast forward merge"
  </div></li>
  <li><span class=code>prune(args)</span>
  <span class=code>prune branch [id]</span> delete branch by moving it to backup directory.</li>
  <li><span class=code>export(args) -&gt; to</span>
  <span class=code>export branch to/</span>: copy all patch files in the branch to <span class=code>to/</span>.
  
  <div class=info>the resulting directory is commonly sent to <span class=code>tar -zcvf branch.tar.gz path/</span>
  and then <span class=code>branch.tar.gz</span> sent to a maintainer to be merged
  </div></li>
  <li><span class=code>snap(args) -&gt; snap/</span>
  <span class=code>snap [branch#id]</span> get the snapshot directory of branch#id
  (default=at).
  
  The snapshot contains a copy of files at that commit and
  should not be modified.</li>
</ul>
<p>
<h1><a id=""pvc.unix"" href="#"pvc.unix"">Mod pvc.unix</h1></a>
<p>
<b>Functions</b> <ul>
  <li><span class=code>diff(a,al, b,bl) -&gt; string?</span>
  Get the unified diff using unix <span class=code>diff --unified=1</span>,
  properly handling file creation/deleting
  the <span class=code>l</span> variables are the "label" to use.
  when the coresponding value is nil then the label is <span class=code>/dev/null</span></li>
  <li><span class=code>patch(cwd, path)</span>
  forward patch</li>
  <li><span class=code>rpatch(cwd, path)</span>
  reverse patch</li>
  <li><span class=code>merge(to, base, change) -&gt; ok, err</span>
  incorporate all changes that went into going from base to change into to</li>
</ul>
<p>
</div></body>
</html>
