<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1>fmt: format lua types</h1>
The fmt module is a small module which formats arbitrary lua types as well as
enables users to define formatting for their own <a href="metaty.html">metatypes</a> via
the <span class=code>:__fmt(fmter)</span> method.

<p>
<p>It also provides several helper methods such as <span class=code>print</span>, <span class=code>assertf</span> and
<span class=code>errorf</span>, making it more convienent to print or format types. In addition, it
sets <span class=code>io.fmt = io.fmt or Fmt{to=io.stderr}</span>, providing a default hook for
<a href="ds.html#ds.log">ds.html#ds.log</a> and command line utilities to write formatted text to.

<p>
<p>The <a href="#fmt.Fmt">#fmt.Fmt</a> interface (which is passed to a metaty's <span class=code>__fmt</span> method if
present) accepts both <span class=code>:write(...)</span> (like a file) and
<span class=code>:styled("style", "styled text", ..."non-styled text")</span>, enabling the
<a href="asciicolor.html">asciicolor</a> library (or your own library!) to provide
user-configurable colors for specific styles which integrate with the
<a href="vt100.html">vt100</a> library and the <a href="cxt.html">cxt</a> libraries. This is used
throughout civstack to provide user-configurable (and optional) color
to the terminal, web-pages and the <a href="ele.html">ele</a> editor.

<p><h3><a id="fmt" href="#fmt" class=anchor>Mod fmt</h3></a>
format module: format any type into a readable string

<p>
<p><b>Types: </b><a href="#fmt.Fmt">Fmt</a> 

<p><b>Functions</b> <ul>
  <li><a id="fmt.cmpDuck" href="#fmt.cmpDuck" class=anchor><b>fn cmpDuck</b></a><span class=code>(a, b)</span><br>
  
  Compares two values of any type.
  
  <p>Note: <span class=code>nil &lt; bool &lt; number &lt; string &lt; table</span></li>
  <li><a id="fmt.sortKeys" href="#fmt.sortKeys" class=anchor><b>fn sortKeys</b></a><span class=code>(t) -&gt; list</span><br>
  
  Return a list of the table's keys sorted using <span class=code>cmpDuck</span></li>
  <li><a id="fmt.tostring" href="#fmt.tostring" class=anchor><b>fn tostring</b></a><span class=code>(v, fmt)</span><br>
  
  Similar to lua's <span class=code>tostring()</span> function except formats
  tables/types.</li>
  <li><a id="fmt.format" href="#fmt.format" class=anchor><b>fn format</b></a><span class=code>(fmt, ...)</span><br>
  
  Similar to lua's <span class=code>string.format(...)</span> function
  except <span class=code>%q</span> formats tables/types.</li>
  <li><a id="fmt.errorf" href="#fmt.errorf" class=anchor><b>fn errorf</b></a><span class=code>(...)</span><br>
  
  Shortcut for <span class=code>error(fmt.format(...))</span></li>
  <li><a id="fmt.assertf" href="#fmt.assertf" class=anchor><b>fn assertf</b></a><span class=code>(a, ...) -&gt; a</span><br>
  
  Asserts <span class=code>a</span> else throws <span class=code>error(fmt.format(...))</span>.</li>
  <li><a id="fmt.fprint" href="#fmt.fprint" class=anchor><b>fn fprint</b></a><span class=code>(fmter, ...)</span><br>
  
  Writes the formatted arguments to <span class=code>f</span>.</li>
  <li><a id="fmt.print" href="#fmt.print" class=anchor><b>fn print</b></a><span class=code>(...) -&gt; fprint(io.fmt, ...)</span><br>
  
  <span class=code>print(...)</span> but using <span class=code>io.fmt</span>.</li>
  <li><a id="fmt.pprint" href="#fmt.pprint" class=anchor><b>fn pprint</b></a><span class=code>(...)</span><br>
  
  pretty print</li>
  <li><a id="fmt.pretty" href="#fmt.pretty" class=anchor><b>fn pretty</b></a><span class=code>(v) -&gt; string</span><br>
  
  pretty format the value</li>
  <li><a id="fmt.table" href="#fmt.table" class=anchor><b>fn table</b></a><span class=code>(tbl, fmter) -&gt; fmter:rawtable(tbl)</span><br>
  
  Set to __fmt to format a type like a table.</li>
</ul>

<p><h4><a id="fmt.Fmt" href="#fmt.Fmt" class=anchor>Record Fmt</h4></a>
The formatter object.

<p>This is the main API of this module. It enables formatting any
type by simply calling it's instance, writing the result to
<span class=code>to</span> (if set) or just the fmter itself. For the latter, you can construct
the string with <span class=code>fmter:tostring()</span> or just <span class=code>table.concat(fmter)</span>.

<p><b>Fields:</b><ul>
  <li><a id="fmt.Fmt.style" href="#fmt.Fmt.style" class=anchor><b>style</b></a>
  enable styling. If true, set <span class=code>to=Styler</span></li>
  <li><a id="fmt.Fmt.to" href="#fmt.Fmt.to" class=anchor><b>to</b></a>
  if set calls write</li>
  <li><a id="fmt.Fmt.keyEnd" href="#fmt.Fmt.keyEnd" class=anchor><b>keyEnd</b></a> <span class=code>=", "</span></li>
  <li><a id="fmt.Fmt.keySet" href="#fmt.Fmt.keySet" class=anchor><b>keySet</b></a> <span class=code>="="</span></li>
  <li><a id="fmt.Fmt.indexEnd" href="#fmt.Fmt.indexEnd" class=anchor><b>indexEnd</b></a> <span class=code>=", "</span></li>
  <li><a id="fmt.Fmt.tableStart" href="#fmt.Fmt.tableStart" class=anchor><b>tableStart</b></a> <span class=code>="{"</span></li>
  <li><a id="fmt.Fmt.tableEnd" href="#fmt.Fmt.tableEnd" class=anchor><b>tableEnd</b></a> <span class=code>="}"</span></li>
  <li><a id="fmt.Fmt.listEnd" href="#fmt.Fmt.listEnd" class=anchor><b>listEnd</b></a> <span class=code>=""</span>
  separator between list/map</li>
  <li><a id="fmt.Fmt.indent" href="#fmt.Fmt.indent" class=anchor><b>indent</b></a> <span class=code>=" &nbsp;"</span></li>
  <li><a id="fmt.Fmt.maxIndent" href="#fmt.Fmt.maxIndent" class=anchor><b>maxIndent</b></a> <span class=code>=20</span></li>
  <li><a id="fmt.Fmt.numfmt" href="#fmt.Fmt.numfmt" class=anchor><b>numfmt</b></a> <span class=code>="%q"</span></li>
  <li><a id="fmt.Fmt.strfmt" href="#fmt.Fmt.strfmt" class=anchor><b>strfmt</b></a> <span class=code>="%q"</span></li>
  <li><a id="fmt.Fmt.table" href="#fmt.Fmt.table" class=anchor><b>table</b></a> <span class=code>=Fmt.table</span></li>
  <li><a id="fmt.Fmt.string" href="#fmt.Fmt.string" class=anchor><b>string</b></a> <span class=code>=Fmt.string</span></li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Fmt.toPretty" href="#Fmt.toPretty" class=anchor><b>fn:toPretty</b></a><span class=code>()</span></li>
  <li><a id="Fmt.pretty" href="#Fmt.pretty" class=anchor><b>fn pretty</b></a><span class=code>(F, t) -&gt; F(t):toPretty()</span><br>
  
  Create a new Formatter object with default "pretty" settings.
  Generally, this means line-separated and indented tables.</li>
  <li><a id="Fmt.level" href="#Fmt.level" class=anchor><b>fn:level</b></a><span class=code>(add) -&gt; int: current level</span><br>
  
  Add to the indent level and get the new value
  call with <span class=code>add=nil</span> to just get the current level</li>
  <li><a id="Fmt.write" href="#Fmt.write" class=anchor><b>fn:write</b></a><span class=code>(...)</span><br>
  
  Same as <span class=code>file:write</span>.</li>
  <li><a id="Fmt.flush" href="#Fmt.flush" class=anchor><b>fn:flush</b></a><span class=code>()</span></li>
  <li><a id="Fmt.close" href="#Fmt.close" class=anchor><b>fn:close</b></a><span class=code>()</span></li>
  <li><a id="Fmt.styled" href="#Fmt.styled" class=anchor><b>fn:styled</b></a><span class=code>(style, text, ...)</span><br>
  
  Call <span class=code>to:styled(...)</span> if it is enabled, else simply <span class=code>self:write(text, ...)</span>.
  This allows for configurable styling of output, both for objects as well
  as command-line utilities/etc.</li>
  <li><a id="Fmt.tableKey" href="#Fmt.tableKey" class=anchor><b>fn:tableKey</b></a><span class=code>(k)</span><br>
  
  Format like a table key. This can be overriden by type extensions to
  provide other behavior.</li>
  <li><a id="Fmt.nil" href="#Fmt.nil" class=anchor><b>fn nil</b></a><span class=code>(self)</span><br>
  
  format a nil value.</li>
  <li><a id="Fmt.boolean" href="#Fmt.boolean" class=anchor><b>fn:boolean</b></a><span class=code>(b)</span><br>
  
  format a boolean value.</li>
  <li><a id="Fmt.number" href="#Fmt.number" class=anchor><b>fn:number</b></a><span class=code>(n)</span><br>
  
  format a number value.</li>
  <li><a id="Fmt.string" href="#Fmt.string" class=anchor><b>fn:string</b></a><span class=code>(s)</span><br>
  
  format a string value.</li>
  <li><a id="Fmt.thread" href="#Fmt.thread" class=anchor><b>fn:thread</b></a><span class=code>(th)</span><br>
  
  format a thread value.</li>
  <li><a id="Fmt.userdata" href="#Fmt.userdata" class=anchor><b>fn:userdata</b></a><span class=code>(ud)</span><br>
  
  format a userdata value.</li>
  <li><a id="Fmt.function" href="#Fmt.function" class=anchor><b>fn function</b></a><span class=code>(self, fn)</span><br>
  
  format a function value.</li>
  <li><a id="Fmt.items" href="#Fmt.items" class=anchor><b>fn:items</b></a><span class=code>(t, hasKeys, listEnd)</span><br>
  
  format items in table "list"</li>
  <li><a id="Fmt.keyvals" href="#Fmt.keyvals" class=anchor><b>fn:keyvals</b></a><span class=code>(t, keys)</span><br>
  
  format key/vals in table "map".</li>
  <li><a id="Fmt.list" href="#Fmt.list" class=anchor><b>fn:list</b></a><span class=code>(t)</span><br>
  
  Format only the list-elements of a table.</li>
  <li><a id="Fmt.rawtable" href="#Fmt.rawtable" class=anchor><b>fn:rawtable</b></a><span class=code>(t)</span></li>
  <li><a id="Fmt.table" href="#Fmt.table" class=anchor><b>fn:table</b></a><span class=code>(t)</span><br>
  
  Recursively format a table.
  Yes this is complicated. No, there is no way to really improve
  this while preserving the features.</li>
  <li><a id="Fmt.format" href="#Fmt.format" class=anchor><b>fn:format</b></a><span class=code>(fmt, ...) -&gt; varargsUsed</span><br>
  
  like string.format but use <span class=code>Fmt</span> for <span class=code>%q</span>.
  Doesn't return the string, instead writes to <span class=code>Fmt</span></li>
  <li><a id="Fmt.concat" href="#Fmt.concat" class=anchor><b>fn:concat</b></a><span class=code>(sep, ...) -&gt; self</span><br>
  
  fmt ... separated by sep</li>
  <li><a id="Fmt.tabulated" href="#Fmt.tabulated" class=anchor><b>fn:tabulated</b></a><span class=code>('\t', ...)</span><br>
  
  fmt ... separated by tabs</li>
  <li><a id="Fmt.lined" href="#Fmt.lined" class=anchor><b>fn:lined</b></a><span class=code>('\n', ...)</span><br>
  
  fmt ... separated by newlines</li>
  <li><a id="Fmt.tostring" href="#Fmt.tostring" class=anchor><b>fn:tostring</b></a><span class=code>()</span><br>
  
  Returns the concattenated string written to the
  formatter.<br>
  
  Error if <span class=code>to</span> is set.</li>
</ul>

<p><h4><a id="fmt.binary" href="#fmt.binary" class=anchor>Command fmt.binary</h4></a>
Library to format binary text.

<p>Cmd usage: <span class=code>seebin path/to/file.bin</span>
<b>Arguments:</b><ul>
  <li><a id="fmt.binary.width" href="#fmt.binary.width" class=anchor><b>width</b></a> <span class=code>=16</span>
  column width in bytes</li>
  <li><a id="fmt.binary.fmt" href="#fmt.binary.fmt" class=anchor><b>fmt</b></a> <span class=code>="%.2x "</span>
  format string for hex</li>
  <li><a id="fmt.binary.to" href="#fmt.binary.to" class=anchor><b>to</b></a>
  file to output to</li>
  <li><a id="fmt.binary.i" href="#fmt.binary.i" class=anchor><b>i</b></a> <span class=code>=0</span>
  starting index to use</li>
</ul>
<b>Methods and Functions</b> <ul>
  <li><a id="fmt.binary.format" href="#fmt.binary.format" class=anchor><b>fn format</b></a><span class=code>(f, str, fmt)</span></li>
  <li><a id="fmt.binary.ascii" href="#fmt.binary.ascii" class=anchor><b>fn ascii</b></a><span class=code>(f, str)</span></li>
  <li><a id="fmt.binary.columns" href="#fmt.binary.columns" class=anchor><b>fn columns</b></a><span class=code>(f, str, width, si, fmt)</span></li>
  <li><a id="fmt.binary.bstring" href="#fmt.binary.bstring" class=anchor><b>fn bstring</b></a><span class=code>(...) -&gt; string</span><br>
  
  Simple API to get the concatenated arguments as binary.</li>
</ul>

<p>
</div></body>
</html>
