<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1>Ele: Extendable Lua Editor</h1>
<br>
Ele is an (**In Development**) <b>E</b>xtendable <b>L</b>ua <b>E</b>ditor.
<br>
Ele's primary goals are: <ul>
  <li>Implemented in a minimal amount of understandable code. It is the main editor
  for Civboot</li>
  <li>Enjoyable and extendable for developers to fit their workflow <ul>
    <li>undo/redo, syntax highlighting, plugins, user-configurable bindings
    (supports vim/emacs style), etc.</li>
  </ul></li>
  <li>Implements a lua shell (zsh competitor)</li>
  <li>Can handle any size text file</li>
  <li>Cross platform (currently vt100-only protocol, which should run anywhere)</li>
</ul>
<br>
Non-goals of Ele are: <ul>
  <li>Focusing on performance against the other goals. It should be fast enough
  to be an editor and should not choke on large files -- otherwise performance
  is not important.</li>
</ul>
<br>
<h1>Architecture</h1>
<br>
Ele is architected using the MVI (model-view-intent) architecture, also
known as the "React architecture" from the web library of the same
name.
<br>
<div class=code-block>&nbsp; &nbsp;,_____________________________________________<br>
&nbsp; &nbsp;| intent(): keyboard, timer, executor, etc &nbsp; &nbsp;|<br>
&nbsp; &nbsp;`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'<br>
&nbsp; &nbsp;/\ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| Data + events<br>
&nbsp; &nbsp;|| Data + scheduled &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/<br>
&nbsp; ,__________________ &nbsp; Data + scheduled ,____________________________<br>
&nbsp; | view(): paint &nbsp; &nbsp;| &lt;================ | model(): keybind, actions &nbsp;|<br>
&nbsp; `~~~~~~~~~~~~~~~~~~' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
</div>
<br>
In practice, this is accomplished in four coroutines spawned
by <a href="ele.lua">ele.lua</a>'s <span class=code>main</span> function: <ul>
  <li>A coroutine that listens to stdin for vt100 key sequences
  and sends event (plain-old-table values) to the <span class=code>keys</span>
  channel.</li>
  <li>A coroutine that listens to key actions and converts them
  to events (again, plain-old-tables) based on the ele.bindings,
  which are sent on an events channel. This also handles
  chords correctly, see the ele.bindings documentation.</li>
  <li>A coroutine that listens for event tables, looks up their
  <span class=code>action</span> in ele.actions and runs the appropriate action.</li>
  <li>A coroutine that "draws" the current display once per "frame"
  This is done by recursing the tree from <span class=code>Editor.root</span> down,
  having them write the relevant text to a vt100.Term object,
  which gets flushed to the display at the end.</li>
</ul>
<br>
This roughly implements the MVI architecture because ALL actions
are performed sequentially based on the ordering in the <span class=code>events</span>
channel.
<br>
Actions or plugins have the option to spawn their own coroutine. However,
this behavior should be extremely rare, and reserved mostly for things that
really can happen concurrently with no user feedback needed, such as saving a
file, finding file lints, or updating syntax highlighting. Most real-world
editor operations can block the user while they happen, and if they can't
then they should consider not being included as an editor operation. Some
exceptions such as searching for patterns in a recursive tree should be
spawned as a coroutine but be cancelled if the user modifies the buffer
that the results are being written to in any way.
<br>
<h1>Adding Bindings</h1>
Adding simple bindings is easy. Simply insert the space-separated chord
of keys you want to go to your binding to one of ele's default modes, or
create your own.  ele.bindings's <span class=code>command</span>, <span class=code>insert</span> and/or <span class=code>system</span>
entries are where you will find the default modes. For instance,
the following will insert the expected text at the cursor position
from command mode:
<br>
<div class=code-block>local B = require'ele.bindings'<br>
B.command['y y'] = {action='insert', 'Why oh why did I bind this?\n'},
</div>
<br>
To write your own action you must: <ul>
  <li>Add a callable to ele.actions which implements the intended behavior. The
  signature is: <span class=code>fn(Editor, event, Channel[event</span>)</li>
</ul>. You may modify the Editor
in the appropriate way for your action.  You are recommended to handle
<span class=code>event.times</span> to do your action multiple times (if that makes sense for your
action). Note that you are free to throw errors -- any errors will be caught
and logged.
<br>
* Add a binding to an editor mode. The binding can either be a plain table,
which is the event that will be generated, or a <span class=code>fn(KeySt) -&gt; ev?</span> callable.
Using the callable API is slightly complex but allows for complex key
interactions where you build-up a command with a chaing (aka "chord") of
multiple key inputs. Refer to the ele.bindings documentation.
</div></body>
</html>
