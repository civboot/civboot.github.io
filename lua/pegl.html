<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
PEG like recursive descent Parser for Lua.
<br>
PEG stands for "Parsing Expression Grammar" and is one of the simplest parsing
grammars since it maps very-closesly to recursive descent -- which is a
hand-rolled parser that uses recursion. This library is a pure-LUA
recursive-descent parser which exports types and functions to create a PEG-like
DSL that is still just recursive descent under the hood.
<br>
The benefits of this library are: <ul>
  <li><i>vs hand-rolled recursive descent</i> is more concise and readable, as well as
  providing automatic error messages (i.e. symbol locations in your stack) and
  debugging.</li>
  <li><i>vs PEG</i> is nearly as concise while maintaining the ability to hand-roll any
  logic needed.</li>
</ul>
<br>
<h2><a id="pegl-resources" href="#pegl-resources" class=anchor>Resources</h2></a>
If you are completely new to parsers and especially if you want to write your
own language with an AST then I cannot recommend
<a href="http://www.craftinginterpreters.com">http://www.craftinginterpreters.com</a> enough. It might be a better place to
start than this library.
<br>
<h2><a id="pegl-intro" href="#pegl-intro" class=anchor>Introduction</h2></a>
A parser is a way to convert text into structured node objects so that the text
can be compiled or annotated by a program. For example you might want to convert
some source code like:
<br>
<div class=code-block>x = 1 + 2</div>
<br>
Into something like:
<br>
<div class=code-block>{'x', '=', {'1', '+', '2', kind='op'}, kind='assign'}</div>
<br>
A recursive descent parser does so via hand-rolled functions which typically
<i>recurse</i> into eachother. Each function attempts to parse from the current
parser position using its spec (which may be composed of calling other parsing
functions) and returns either the successfully parsed node or <span class=code>nil</span> (or
returns/throws an error if it finds a syntax error).
<br>
PEGL is a Lua library for writing the common-cases of a recursive descent parser
in a (pure Lua) syntax similar to PEG, while still being able to easily fallback
to hand-rolled recursive descent when needed.
<br>
Most traditional PEG parsers (as well as other parsers) struggle with
complicated syntax such as Lua's <span class=code>[===[raw string syntax]===]</span>, python's
whitespace denoted syntax or C's lookahead requirements (<span class=code>(U2)*c**h</span> --
recursive descent can solve a lot of these problems relatively easily and
performantly.  However, recursive descent parsers can be very verbose and
sometimes difficult to understand. Below is a comparison of the above example
in both PEG, PEGL and a "traditional" (though not very good) recursive descent
implementation.
<br>
<h3>Examples</h3>
<br>
<b>PEG</b>: most concise but harder to fallback to hand-rolled recursive descent
<div class=code-block>grammar = [[<br>
num &nbsp; &nbsp;&lt;- '%d'<br>
name &nbsp; &lt;- '%w'<br>
setVar &lt;- num '=' name<br>
expr &nbsp; &lt;- setVar / ... other valid expressions<br>
]]<br>
p:parse(grammar)
</div>
<br>
<b>PEGL</b>: very concise and easy to fallback to hand-rolled recursive descent.
Things like `kind` and `name` make debug printing easier. Simply name your
specs, putting them together into a root spec and parsing:
<br>
<div class=code-block>num &nbsp; &nbsp;= Pat{'%d+', kind='num'} -- kind=num sets the node name<br>
name &nbsp; = Pat{'%w+', kind='name'}<br>
-- Note: UNPIN and PIN are used for when errors should be raised<br>
setVar = {UNPIN, name, '=', PIN, num, kind='setVar'}<br>
expr &nbsp; = Or{setVar, ... other valid expressions, name='expr'}<br>
p:parse(expr)<br>
]<br>
<br>
["Note: the difference between name and kind is that a node<br>
&nbsp; with [$kind] set will [*never be unpacked]. For instance,<br>
&nbsp; to define a [$block; of; items;] you might use [$name] since you want<br>
&nbsp; [$single;] to not be represented as just [$single] instead of<br>
&nbsp; [$block { single }].<br>
]<br>
<br>
[*Recursive Descent]: not very concise, harder to debug. [{$$ lang=lua}<br>
-- Note: p=parser, an object which tracks the current position<br>
-- in it's `state`<br>
<br>
function parseNum(p)<br>
&nbsp; local num = p:consume('%d+') -- return result and advance position<br>
&nbsp; if num then -- found<br>
&nbsp; &nbsp; return {num, kind='num'} end<br>
&nbsp; end<br>
end<br>
<br>
function parseSetVar(p)<br>
&nbsp; local state = p.state()<br>
&nbsp; local name = p:consume('%w+')<br>
&nbsp; if not name then return end<br>
&nbsp; local eq, num = p:consume('='), parseNum(p)<br>
&nbsp; if not (eq and num) then<br>
&nbsp; &nbsp; -- didn't match, reset state and return<br>
&nbsp; &nbsp; p.setState(state)<br>
&nbsp; &nbsp; return<br>
&nbsp; end<br>
&nbsp; return {{name, kind='name'}, eq, num, kind='setVar'}<br>
end<br>
<br>
function expression(p)<br>
&nbsp; local expr = parseSetVar(p)<br>
&nbsp; if expr then return expr end<br>
&nbsp; -- ... other possible expressions<br>
end<br>
<br>
expression(p)
</div>
<br>
See <a href="#pegl.Seq">#pegl.Seq</a> for the basic API of parsing specs.
<br>
<h3><a id="pegl" href="#pegl" class=anchor>Mod pegl</h3></a>
pegl: peg-like lua parser
<br>
<b>Types: </b><a href="#pegl.Token">Token</a> <a href="#pegl.Config">Config</a> <a href="#pegl.Parser">Parser</a> <a href="#pegl.Pat">Pat</a> <a href="#pegl.Key">Key</a> <a href="#pegl.Or">Or</a> <a href="#pegl.Many">Many</a> <a href="#pegl.Seq">Seq</a> <a href="#pegl.Not">Not</a> <a href="#pegl.common">common</a> <a href="#pegl.FmtPegl">FmtPegl</a> 
<br>
<b>Functions</b> <ul>
  <li><a id="pegl.encodeSpan" href="#pegl.encodeSpan" class=anchor><b>fn encodeSpan</b></a><span class=code>(l1, c1, l2, c2)</span></li>
  <li><a id="pegl.decodeSpan" href="#pegl.decodeSpan" class=anchor><b>fn decodeSpan</b></a><span class=code>(s)</span></li>
  <li><a id="pegl.firstToken" href="#pegl.firstToken" class=anchor><b>fn firstToken</b></a><span class=code>(list) -&gt; t, listWithToken</span></li>
  <li><a id="pegl.lastToken" href="#pegl.lastToken" class=anchor><b>fn lastToken</b></a><span class=code>(list) -&gt; t, listWithToken</span></li>
  <li><a id="pegl.nodeSpan" href="#pegl.nodeSpan" class=anchor><b>fn nodeSpan</b></a><span class=code>(t)</span></li>
  <li><a id="pegl.fmtSpec" href="#pegl.fmtSpec" class=anchor><b>fn fmtSpec</b></a><span class=code>(s, f)</span></li>
  <li><a id="pegl.specToStr" href="#pegl.specToStr" class=anchor><b>fn specToStr</b></a><span class=code>(s, fmt)</span></li>
  <li><a id="pegl.specTy" href="#pegl.specTy" class=anchor><b>fn specTy</b></a><span class=code>(name)</span><br>
  
  Create a parser spec record. These have the fields <span class=code>kind</span> and <span class=code>name</span>
  and must define the <span class=code>parse</span> method.</li>
  <li><a id="pegl.Maybe" href="#pegl.Maybe" class=anchor><b>fn Maybe</b></a><span class=code>(spec) -&gt; M.Or{spec, M.Empty}</span></li>
  <li><a id="pegl.isEmpty" href="#pegl.isEmpty" class=anchor><b>fn isEmpty</b></a><span class=code>(t) -&gt; mty.eq(M.EMPTY, t)</span></li>
  <li><a id="pegl.notEmpty" href="#pegl.notEmpty" class=anchor><b>fn notEmpty</b></a><span class=code>(t) -&gt; not mty.eq(M.EMPTY, t)</span></li>
  <li><a id="pegl.skipWs1" href="#pegl.skipWs1" class=anchor><b>fn skipWs1</b></a><span class=code>(p)</span></li>
  <li><a id="pegl.skipEmpty" href="#pegl.skipEmpty" class=anchor><b>fn skipEmpty</b></a><span class=code>(p)</span></li>
  <li><a id="pegl.skipEmptyMinimal" href="#pegl.skipEmptyMinimal" class=anchor><b>fn skipEmptyMinimal</b></a><span class=code>(p)</span></li>
  <li><a id="pegl.defaultTokenizer" href="#pegl.defaultTokenizer" class=anchor><b>fn defaultTokenizer</b></a><span class=code>(p)</span></li>
  <li><a id="pegl.parseSeq" href="#pegl.parseSeq" class=anchor><b>fn parseSeq</b></a><span class=code>(p, seq)</span></li>
  <li><a id="pegl.parse" href="#pegl.parse" class=anchor><b>fn parse</b></a><span class=code>(dat, spec, config) -&gt; list[Node]</span><br>
  
  Parse a spec, returning the nodes or throwing a syntax error.
  
  <span class=code>config</span> is used to define settings of the parser such as how to skip
  comments and whether to use debug mode.</li>
  <li><a id="pegl.assertParse" href="#pegl.assertParse" class=anchor><b>fn assertParse</b></a><span class=code>(t) -&gt; result, node, parser</span><br>
  
  Parse the <span class=code>dat</span> with the <span class=code>spec</span>, asserting the resulting "string tokens"
  are identical to <span class=code>expect</span>.
  
  the input is a table of the form: <div class=code-block>&nbsp; &nbsp; {dat, spec, expect, dbg=nil, config=default} --&gt; nil<br>
&nbsp; 
</div></li>
  <li><a id="pegl.assertParseError" href="#pegl.assertParseError" class=anchor><b>fn assertParseError</b></a><span class=code>(t)</span></li>
  <li><a id="pegl.isKeyword" href="#pegl.isKeyword" class=anchor><b>fn isKeyword</b></a><span class=code>(t) -&gt; #t == 1 and t.kind == t[1]</span></li>
</ul>
<br>
<h4><a id="pegl.Token" href="#pegl.Token" class=anchor>Record Token</h4></a>
<b>Fields:</b><ul>
  <li><a id="pegl.Token.kind" href="#pegl.Token.kind" class=anchor><b>kind</b></a>
  optional, used for debugging</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Token.span" href="#Token.span" class=anchor><b>fn span</b></a><span class=code>(t, dec) -&gt; M.decodeSpan(t[1])</span></li>
  <li><a id="Token.encode" href="#Token.encode" class=anchor><b>fn encode</b></a><span class=code>(ty_, p, l, c, l2, c2, kind)</span></li>
  <li><a id="Token.decode" href="#Token.decode" class=anchor><b>fn decode</b></a><span class=code>(t, dat) -&gt; lines.sub(dat, M.decodeSpan(t[1]))</span></li>
</ul>
<br>
<h4><a id="pegl.Config" href="#pegl.Config" class=anchor>Record Config</h4></a>
The config spec defines custom behavior when parsing. It's attributes
can be set to change how the parser skips empty (whitespace) and handles comments.
<br>
<b>Fields:</b><ul>
  <li><a id="pegl.Config.skipEmpty" href="#pegl.Config.skipEmpty" class=anchor><b>skipEmpty</b></a> <span class=code>=pegl.skipEmpty</span>
  default=skip whitespace <ul>
    <li>must be a function that accepts the `Parser`
    and advances it's `l` and `c` past any empty (white) space. It must also set
    `p.line` appropriately when `l` is moved.</li>
    <li>The return value is ignored.</li>
    <li>The default is to skip all whitespace (spaces, newlines, tabs, etc). This
    should work for _most_ languages but fails for languages like python.</li>
    <li>Recommendation: If your language has only a few whitespace-aware nodes (i.e.
    strings) then hand-roll those as recursive-descent functions and leave
    this function alone.</li>
  </ul></li>
  <li><a id="pegl.Config.skipComment" href="#pegl.Config.skipComment" class=anchor><b>skipComment</b></a>
  fn(p) -> Token for found comment</li>
  <li><a id="pegl.Config.tokenizer" href="#pegl.Config.tokenizer" class=anchor><b>tokenizer</b></a> <span class=code>=pegl.defaultTokenizer</span>
  Requires: <ul>
    <li>must return one token. The default is to return a single punctuation character
    or a whole word (<span class=code>_%w</span>)</li>
    <li>Objects like <span class=code>Key</span> can use the single punctuation characters in a Trie-like
    performant data structure.</li>
  </ul></li>
  <li><a id="pegl.Config.dbg" href="#pegl.Config.dbg" class=anchor><b>dbg</b></a>
  if true, prints out huge amounts of debug information of parsing.</li>
  <li><a id="pegl.Config.lenient" href="#pegl.Config.lenient" class=anchor><b>lenient</b></a>
  if set, syntax errors do not cause failure.
  Instead, all errors act as if the current block missed but was UNPIN.</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Config.skipEmpty" href="#Config.skipEmpty" class=anchor><b>fn skipEmpty</b></a><span class=code>(p)</span></li>
  <li><a id="Config.tokenizer" href="#Config.tokenizer" class=anchor><b>fn tokenizer</b></a><span class=code>(p)</span></li>
  <li><a id="Config.newFmt" href="#Config.newFmt" class=anchor><b>fn newFmt</b></a><span class=code>()</span></li>
</ul>
<br>
<h4><a id="pegl.Parser" href="#pegl.Parser" class=anchor>Record Parser</h4></a>
The parser tracks the current position of parsing in `dat` and has several
convienience methods for hand-rolling your own recursive descent functions.
<br>
<div class=info> Note: the location is **line/col based** (not position based) because it
is designed to work with an application that stores the strings as lines
(a text editor) </div>
<br>
<b>Fields:</b><ul>
  <li><a id="pegl.Parser.dat" href="#pegl.Parser.dat" class=anchor><b>dat</b></a>
  reference to the underlying data.
  Must look like a table of lines</li>
  <li><a id="pegl.Parser.l" href="#pegl.Parser.l" class=anchor><b>l</b></a>
  line, incremented when <span class=code>c</span> is exhausted</li>
  <li><a id="pegl.Parser.c" href="#pegl.Parser.c" class=anchor><b>c</b></a>
  column in <span class=code>line</span></li>
  <li><a id="pegl.Parser.line" href="#pegl.Parser.line" class=anchor><b>line</b></a>
  the current line (<span class=code>dat:get(l)</span>)</li>
  <li><a id="pegl.Parser.lines" href="#pegl.Parser.lines" class=anchor><b>lines</b></a></li>
  <li><a id="pegl.Parser.config" href="#pegl.Parser.config" class=anchor><b>config</b></a></li>
  <li><a id="pegl.Parser.stack" href="#pegl.Parser.stack" class=anchor><b>stack</b></a></li>
  <li><a id="pegl.Parser.stackL" href="#pegl.Parser.stackL" class=anchor><b>stackL</b></a></li>
  <li><a id="pegl.Parser.stackC" href="#pegl.Parser.stackC" class=anchor><b>stackC</b></a></li>
  <li><a id="pegl.Parser.stackLast" href="#pegl.Parser.stackLast" class=anchor><b>stackLast</b></a></li>
  <li><a id="pegl.Parser.commentLC" href="#pegl.Parser.commentLC" class=anchor><b>commentLC</b></a>
  table of {line={col=CommentToken}}</li>
  <li><a id="pegl.Parser.dbgLevel" href="#pegl.Parser.dbgLevel" class=anchor><b>dbgLevel</b></a> <span class=code>=0</span></li>
  <li><a id="pegl.Parser.path" href="#pegl.Parser.path" class=anchor><b>path</b></a></li>
  <li><a id="pegl.Parser.firstError" href="#pegl.Parser.firstError" class=anchor><b>firstError</b></a>
  first error.</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Parser.assertNode" href="#Parser.assertNode" class=anchor><b>fn assertNode</b></a><span class=code>(p, expect, node, config)</span></li>
  <li><a id="Parser.new" href="#Parser.new" class=anchor><b>fn new</b></a><span class=code>(T, dat, config)</span></li>
  <li><a id="Parser.parse" href="#Parser.parse" class=anchor><b>fn parse</b></a><span class=code>(p, spec) -&gt; node</span><br>
  
  the main entry point and used recursively.
  Parses the spec, returning the node, which is a table of nodes that are
  eventually tokens.</li>
  <li><a id="Parser.consume" href="#Parser.consume" class=anchor><b>fn consume</b></a><span class=code>(p, pat, plain) -&gt; Token</span><br>
  
  consume the pattern, advancing the column if found</li>
  <li><a id="Parser.peek" href="#Parser.peek" class=anchor><b>fn peek</b></a><span class=code>(p, pat)</span><br>
  
  identical to `consume` except it does not advance the column</li>
  <li><a id="Parser.sub" href="#Parser.sub" class=anchor><b>fn sub</b></a><span class=code>(p, t)</span></li>
  <li><a id="Parser.incLine" href="#Parser.incLine" class=anchor><b>fn incLine</b></a><span class=code>(p)</span></li>
  <li><a id="Parser.isEof" href="#Parser.isEof" class=anchor><b>fn isEof</b></a><span class=code>(p) -&gt; isAtEndOfFile</span></li>
  <li><a id="Parser.skipEmpty" href="#Parser.skipEmpty" class=anchor><b>fn skipEmpty</b></a><span class=code>(p)</span></li>
  <li><a id="Parser.state" href="#Parser.state" class=anchor><b>fn state</b></a><span class=code>(p) -&gt; {l=p.l, c=p.c, line=p.line}</span><br>
  
  get the current parser state <span class=code>{l, c, line}</span></li>
  <li><a id="Parser.setState" href="#Parser.setState" class=anchor><b>fn setState</b></a><span class=code>(p, st)</span><br>
  
  restore the current parser state <span class=code>{l, c, line}</span></li>
  <li><a id="Parser.toStrTokens" href="#Parser.toStrTokens" class=anchor><b>fn toStrTokens</b></a><span class=code>(p, n)</span></li>
  <li><a id="Parser.makeStrTokens" href="#Parser.makeStrTokens" class=anchor><b>fn makeStrTokens</b></a><span class=code>(p, t) -&gt; t</span><br>
  
  recursively mutate table converting all Tokens to strings</li>
  <li><a id="Parser.tokenStr" href="#Parser.tokenStr" class=anchor><b>fn tokenStr</b></a><span class=code>(p, t) -&gt; string</span></li>
  <li><a id="Parser.trimTokenStart" href="#Parser.trimTokenStart" class=anchor><b>fn trimTokenStart</b></a><span class=code>(p, list)</span></li>
  <li><a id="Parser.trimTokenLast" href="#Parser.trimTokenLast" class=anchor><b>fn trimTokenLast</b></a><span class=code>(p, list, trimNl)</span></li>
  <li><a id="Parser.checkPin" href="#Parser.checkPin" class=anchor><b>fn checkPin</b></a><span class=code>(p, pin, expect)</span></li>
  <li><a id="Parser.error" href="#Parser.error" class=anchor><b>fn error</b></a><span class=code>(p, msg)</span></li>
  <li><a id="Parser.parseAssert" href="#Parser.parseAssert" class=anchor><b>fn parseAssert</b></a><span class=code>(p, spec)</span></li>
  <li><a id="Parser.dbgEnter" href="#Parser.dbgEnter" class=anchor><b>fn dbgEnter</b></a><span class=code>(p, spec)</span></li>
  <li><a id="Parser.dbgLeave" href="#Parser.dbgLeave" class=anchor><b>fn dbgLeave</b></a><span class=code>(p, n)</span></li>
  <li><a id="Parser.dbgMatched" href="#Parser.dbgMatched" class=anchor><b>fn dbgMatched</b></a><span class=code>(p, spec)</span></li>
  <li><a id="Parser.dbgMissed" href="#Parser.dbgMissed" class=anchor><b>fn dbgMissed</b></a><span class=code>(p, spec, note)</span></li>
  <li><a id="Parser.dbgUnpack" href="#Parser.dbgUnpack" class=anchor><b>fn dbgUnpack</b></a><span class=code>(p, spec, t)</span></li>
  <li><a id="Parser.dbg" href="#Parser.dbg" class=anchor><b>fn dbg</b></a><span class=code>(p, fmtstr, ...)</span></li>
</ul>
<br>
<h4><a id="pegl.Pat" href="#pegl.Pat" class=anchor>Record Pat</h4></a>
<span class=code>Pat{'%w+', kind='word'}</span> will create a Token with the span matching the
<span class=code>%w+</span> pattern and the kind of <span class=code>word</span> when matched.
<br>
<b>Fields:</b><ul>
  <li><a id="pegl.Pat.kind" href="#pegl.Pat.kind" class=anchor><b>kind</b></a></li>
  <li><a id="pegl.Pat.name" href="#pegl.Pat.name" class=anchor><b>name</b></a></li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Pat.set" href="#Pat.set" class=anchor><b>fn set</b></a><span class=code>(name)</span><br>
  
  Create a parser spec record. These have the fields <span class=code>kind</span> and <span class=code>name</span>
  and must define the <span class=code>parse</span> method.</li>
  <li><a id="Pat.get" href="#Pat.get" class=anchor><b>fn get</b></a><span class=code>(name)</span><br>
  
  Create a parser spec record. These have the fields <span class=code>kind</span> and <span class=code>name</span>
  and must define the <span class=code>parse</span> method.</li>
  <li><a id="Pat.extend" href="#Pat.extend" class=anchor><b>fn extend</b></a><span class=code>(r, l) -&gt; r</span></li>
  <li><a id="Pat.parse" href="#Pat.parse" class=anchor><b>fn parse</b></a><span class=code>(self, p)</span></li>
</ul>
<br>
<h4><a id="pegl.Key" href="#pegl.Key" class=anchor>Record Key</h4></a>
The table given to <span class=code>Key</span> forms a Trie which is extremely performant. Key depends
strongly on the <span class=code>tokenizer</span> passed to Config.
<br>
Example: <span class=code>Key{{'myKeword', ['+'</span>={'+'=true}}, kind='kw'}
</div></body>
</html>
