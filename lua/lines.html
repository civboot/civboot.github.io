<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1>lines: view files as list of lines</h1>
The <span class=code>lines</span> library (and it's submodules) enable line-based processing of
text. The <a href="#lines">#lines</a> module itself exports an API that work on both a list of
strings (aka lines) or deal with files as indexed lines (i.e. <a href="#lines.File">#lines.File</a>)

<p>
<p><span class=code>lines</span> is the fundamental building block of civstack's <a href="ele.html">ele</a> editor
and <a href="cxt.html">pegl></a> parsers: it is much easier as a developer to think about
human-readable text as a list of lines then as a list of bytes and this is
especially true for an editor. <a href="#lines.File">#lines.File</a> and <a href="#lines.EdFile">#lines.EdFile</a> use
a separate index file to make reading and writing to files as lines
actually performant for more real-world use-cases.

<p><h2>sub / insert / remove semantics</h2>
<span class=code>lines.sub(t, l,c, l2,c2)</span> returns the text from span l.c -> l2.c2.

<p>For instance: suppose you have the following text:<div class=code-block>1234 6789<br>
abcd fghi
</div>

<p>You would get the following values: <div class=table><table>
  <tr>
    <td>1.1  1.2</td>
    <td><span class=code>{'12'}</span></td>
  </tr>
  <tr>
    <td>1.6  1.10</td>
    <td><span class=code>{'6789', ''}</span> - last char goes to next line</td>
  </tr>
  <tr>
    <td>1.6  2.0</td>
    <td><span class=code>{'6789', ''}</span> - next line zero char the same</td>
  </tr>
  <tr>
    <td>1.6  2.2</td>
    <td><span class=code>{'6789', 'ab'}</span></td>
  </tr>
  <tr>
    <td>1.10 2.2</td>
    <td><span class=code>{'', 'ab'}</span></td>
  </tr>
  <tr>
    <td>1.10 3.0</td>
    <td><span class=code>{'', 'abcd fghi'}</span> - EoF does not have new line</td>
  </tr>
</table></div>

<p>The methods <span class=code>span remove offset offsetOf insert</span> are all designed to
use these conventions to enable reversibility. When you remove a span, it will
modify the lines object in-place, returning the span you removed. If you
re-insert that span in the same place it will return the table to it's previous
state. Along with being easy to understand, this architecture if fundamental to
how undo/redo works in the Ele editor.

<p>
<p>
<p><h3><a id="lines" href="#lines" class=anchor>Mod lines</h3></a>
The lines module, providing a uniform API for lines-like objects.

<p>
<p>
<p><div class=info>You can also call this module directly to get a table of lines

<p>from a string</div>

<p><b>Functions</b> <ul>
  <li><a id="lines.join" href="#lines.join" class=anchor><b>fn join</b></a><span class=code>(t) -&gt; string</span><br>
  
  Join a table of strings with newlines.</li>
  <li><a id="lines.span" href="#lines.span" class=anchor><b>fn span</b></a><span class=code>(l, c, l2, c2) -&gt; (l, c?, l2, c2?)</span><br>
  
  Enables addressing lines via either (l,l2) or (l,c, l2,c2) span.</li>
  <li><a id="lines.bound" href="#lines.bound" class=anchor><b>fn bound</b></a><span class=code>(t, l,c, tlen, ln) -&gt; l, c</span><br>
  
  Bound the line/col for the lines table.<ul>
    <li><span class=code>l</span> will be from <span class=code>1 to #t+1</span>.</li>
    <li><span class=code>c</span> will be from <span class=code>0 to #t[l]+1</span>.</li>
  </ul>
  <span class=code>tlen</span> is precomputed <span class=code>#t</span> and <span class=code>line</span> is pre-fetched <span class=code>t[l]</span>
  
  <p>This can handle negative integers.</li>
  <li><a id="lines.boundSpan" href="#lines.boundSpan" class=anchor><b>fn boundSpan</b></a><span class=code>(t, l,c, l2,c2, tlen)</span><br>
  
  Bound a span from <span class=code>l,c -&gt; l2,c2</span>.</li>
  <li><a id="lines.insert" href="#lines.insert" class=anchor><b>fn insert</b></a><span class=code>(t, ins, l,c) -&gt; nil</span><br>
  
  insert string at l, c<br>
  
  
  <p>Note: this is NOT performant (O(N)) for large tables.<br>
  
  See: <a href="#Gap">#Gap</a> (or similar) for handling real-world workloads.</li>
  <li><a id="lines.sort" href="#lines.sort" class=anchor><b>fn sort</b></a><span class=code>(...) -&gt; l1, c1, l2, c2</span><br>
  
  Sort the span</li>
  <li><a id="lines.sub" href="#lines.sub" class=anchor><b>fn sub</b></a><span class=code>(l, ...) -&gt; {str}, l,c</span><br>
  
  Get the sub-span of the lines.<br>
  </li>
  <li><a id="lines.usub" href="#lines.usub" class=anchor><b>fn usub</b></a><span class=code>(l, ...) -&gt; {str}, l,c</span><br>
  
  Get the UTF8 aware sub-span of the lines.<br>
  </li>
  <li><a id="lines.map" href="#lines.map" class=anchor><b>fn map</b></a><span class=code>(lines) -&gt; table</span><br>
  
  create a table of lineText -> {lineNums}</li>
  <li><a id="lines.offset" href="#lines.offset" class=anchor><b>fn offset</b></a><span class=code>(t, off, l,c) -&gt; l2,c2</span><br>
  
  Get the <span class=code>l, c</span> with the +/- offset applied</li>
  <li><a id="lines.offsetOf" href="#lines.offsetOf" class=anchor><b>fn offsetOf</b></a><span class=code>(t, l,c, l2,c2) -&gt; int</span><br>
  
  get the byte offset </li>
  <li><a id="lines.find" href="#lines.find" class=anchor><b>fn find</b></a><span class=code>(t, pat, l,c) -&gt; (l, c, c2)</span><br>
  
  find the pattern starting at l/c
  Note: matches are only within a single line.</li>
  <li><a id="lines.findBack" href="#lines.findBack" class=anchor><b>fn findBack</b></a><span class=code>(t, pat, l,c)</span><br>
  
  find the pattern (backwards) starting at l/c</li>
  <li><a id="lines.remove" href="#lines.remove" class=anchor><b>fn remove</b></a><span class=code>(t, l,c, l2,c2) -&gt; string|table</span><br>
  
  remove span (l, c) -> (l2, c2), return what was removed</li>
  <li><a id="lines.box" href="#lines.box" class=anchor><b>fn box</b></a><span class=code>(t, l1, c1, l2, c2, fill) -&gt; lines</span><br>
  
  return the box of the lines.
  
  <p><div class=code-block>Outside the box is not returned.<br>
***1------------------------+**<br>
***|l1,c1 = top left &nbsp; &nbsp; &nbsp; &nbsp;|**<br>
***| &nbsp; &nbsp; &nbsp; bot right = l2,c2|<br>
***+------------------------2**<br>
*So no '*' chars are returned.*
</div></li>
  <li><a id="lines.getIndent" href="#lines.getIndent" class=anchor><b>fn getIndent</b></a><span class=code>(t, l) -&gt; str?</span><br>
  
  Get the indentation of line.</li>
  <li><a id="lines.autoIndent" href="#lines.autoIndent" class=anchor><b>fn autoIndent</b></a><span class=code>(t, l) -&gt; string?</span><br>
  
  Get the autoIndent to use for line.</li>
  <li><a id="lines.load" href="#lines.load" class=anchor><b>fn load</b></a><span class=code>(f, close) -&gt; (table?, errstr?)</span><br>
  
  load lines from file or path. On error return (nil, errstr)</li>
  <li><a id="lines.dump" href="#lines.dump" class=anchor><b>fn dump</b></a><span class=code>(t, f, close, chunk)</span><br>
  
  write lines <span class=code>t</span> to file <span class=code>f</span> in chunks (default = 16KiB)
  if f is a string then it is opened as a file and closed when done</li>
  <li><a id="lines.write" href="#lines.write" class=anchor><b>fn write</b></a><span class=code>(t, ...) -&gt; true</span><br>
  
  Logic to make a table behave like a <span class=code>file:write(...)</span> method.
  
  <p>This is NOT performant, especially for large lines.</li>
</ul>

<p><h4><a id="lines.diff" href="#lines.diff" class=anchor>Command lines.diff</h4></a>
Diffing module and command<br>

Cmd Usage: <span class=code>ldiff 'file/path1.txt' 'file/path2.txt'</span><br>

Lib Usage: <span class=code>io.fmt(ldiff.Diff(linesA, linesB))</span><br>


<p>This library/cmd creates readable diffs using the "patience diff" alorithm.
The code was written from scratch referencing only the algorithm outline
below, but I want to give special thanks to James Coglan for his
<a href="https://blog.jcoglan.com/2017/09/19/the-patience-diff-algorithm">
excellent blog post</a>.

<p>
<p>Fundamentals of patience diff: <ul>
  <li>Skip unchanged lines on both top and bottom.</li>
  <li>Find unique lines in both sets and "align" them using "longest increasing
  sequence".</li>
  <li>Repeat for each aligned section.</li>
</ul>

<p><b>Types: </b><a href="#lines.diff.Diff">Diff</a> 

<p>
<p><h4><a id="lines.diff.Diff" href="#lines.diff.Diff" class=anchor>Record Diff</h4></a>
Datastructure which holds the result of computing the difference
between two lists of lines.<br>


<p>Fields <span class=code>b</span> and <span class=code>c</span> are just the original base/change lines.

<p><span class=code>noc</span>, <span class=code>rem</span> and <span class=code>add</span> are lists of integers which represent the length
of a block. For instance, if for a given index <span class=code>rem=3</span> and <span class=code>add=2</span> it
means that three lines were removed from <span class=code>b</span> and two were added to
<span class=code>c</span>. If <span class=code>noc=10</span> that means that there is a block of 10 identical lines.

<p><b>Fields:</b><ul>
  <li><a id="lines.diff.Diff.b" href="#lines.diff.Diff.b" class=anchor><b>b</b></a>
  base, aka raw original lines</li>
  <li><a id="lines.diff.Diff.c" href="#lines.diff.Diff.c" class=anchor><b>c</b></a>
  change, aka raw new lines</li>
  <li><a id="lines.diff.Diff.len" href="#lines.diff.Diff.len" class=anchor><b>len</b></a>
  len of diff blocks (aka len of below fields).
  It's not possible to use # for below, since some values
  are nil.</li>
  <li><a id="lines.diff.Diff.noc" href="#lines.diff.Diff.noc" class=anchor><b>noc</b></a>
  nochange range (in both)</li>
  <li><a id="lines.diff.Diff.rem" href="#lines.diff.Diff.rem" class=anchor><b>rem</b></a>
  removed from b</li>
  <li><a id="lines.diff.Diff.add" href="#lines.diff.Diff.add" class=anchor><b>add</b></a>
  added from c</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Diff.map" href="#Diff.map" class=anchor><b>fn:map</b></a><span class=code>(nocFn, chgFn)</span><br>
  
  Iterate through nochange and change blocks, calling the functions for each
  <ul>
    <li><span class=code>nocFn(baseStart, numUnchanged, changeStart, numUnchanged)</span></li>
    <li><span class=code>chgFn(baseStart, numRemoved, &nbsp; changeStart, numAdded)</span></li>
  </ul>
  Note that the num removed/added will be nil if none were added/removed.</li>
</ul>

<p><h4><a id="lines.Writer" href="#lines.Writer" class=anchor>Record lines.Writer</h4></a>
<b>Deprecated: use ds.bytearray instead. This will be removed.</b>

<p>A lines table with a write method and a few other file-like methods.
This is NOT performant, especially for small writes or large lines. It is
useful for tests and cases where simplicity is more important than
performance.

<p><b>Methods</b> <ul>
  <li><a id="lines.Writer.set" href="#lines.Writer.set" class=anchor><b>fn set</b></a><span class=code>(name)</span><br>
  
  Create a parser spec record. These have the fields <span class=code>kind</span> and <span class=code>name</span>
  and must define the <span class=code>parse</span> method.</li>
  <li><a id="lines.Writer.get" href="#lines.Writer.get" class=anchor><b>fn get</b></a><span class=code>(name)</span><br>
  
  Create a parser spec record. These have the fields <span class=code>kind</span> and <span class=code>name</span>
  and must define the <span class=code>parse</span> method.</li>
  <li><a id="lines.Writer.write" href="#lines.Writer.write" class=anchor><b>fn write</b></a><span class=code>(t, ...) -&gt; true</span><br>
  
  Logic to make a table behave like a <span class=code>file:write(...)</span> method.
  
  <p>This is NOT performant, especially for large lines.</li>
  <li><a id="lines.Writer.flush" href="#lines.Writer.flush" class=anchor><b>fn flush</b></a><span class=code>()</span><br>
  
  function that does and returns nothing.</li>
  <li><a id="lines.Writer.extend" href="#lines.Writer.extend" class=anchor><b>fn extend</b></a><span class=code>(r, l) -&gt; r</span><br>
  
  This is used by types implementing <span class=code>:extend</span>.
  It uses their <span class=code>get</span> and <span class=code>set</span> methods to implement
  extend in a for loop.
  
  <p><div class=info>types do this if they may <span class=code>yield</span> in their get/set, which
  is not allowed through a C boundary like <span class=code>table.move</span></div></li>
  <li><a id="lines.Writer.icopy" href="#lines.Writer.icopy" class=anchor><b>fn icopy</b></a><span class=code>(r)</span><br>
  
  For types implementing <span class=code>:copy()</span> method.</li>
</ul>

<p><h4><a id="Gap" href="#Gap" class=anchor>Record Gap</h4></a>
Line-based gap buffer. The buffer is composed of two lists (stacks) of
lines <ul>
  <li>The "bot" (aka bottom) contains line 1 -> curLine.
  curLine is at #bot. Data gets added to bot.</li>
  <li>The "top" buffer is used to store data in lines
  after "bot" (aka after curLine). If the cursor is
  moved to a previous line then data is moved from top to bot</li>
</ul>

<p><div class=info>Gap gives a file-like write API which may not be the most performant
for some workloads (writing single characters)</div>

<p><b>Fields:</b><ul>
  <li><a id="Gap.top" href="#Gap.top" class=anchor><b>top</b></a>
  array of lines on the top (near start).</li>
  <li><a id="Gap.bot" href="#Gap.bot" class=anchor><b>bot</b></a>
  array of lines on the bottom (near end).</li>
  <li><a id="Gap.path" href="#Gap.path" class=anchor><b>path</b></a>
  the path this was read from or nil.</li>
  <li><a id="Gap.readonly" href="#Gap.readonly" class=anchor><b>readonly</b></a>
  whether to throw errors on write.</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Gap.icopy" href="#Gap.icopy" class=anchor><b>fn:icopy</b></a><span class=code>() -&gt; list</span><br>
  
  Make a copy of the gap to a lua list.</li>
  <li><a id="Gap.reader" href="#Gap.reader" class=anchor><b>fn:reader</b></a><span class=code>() -&gt; Gap</span></li>
  <li><a id="Gap.load" href="#Gap.load" class=anchor><b>fn load</b></a><span class=code>(T, f, close) -&gt; Gap?, err?</span><br>
  
  Load gap from file, which can be a path.
  returns <span class=code>nil, err</span> on error</li>
  <li><a id="Gap.get" href="#Gap.get" class=anchor><b>fn:get</b></a><span class=code>(l) -&gt; string</span><br>
  
  Get a specific line index.</li>
  <li><a id="Gap.set" href="#Gap.set" class=anchor><b>fn:set</b></a><span class=code>(l, v)</span><br>
  
  Set a specific line index with the value.</li>
  <li><a id="Gap.inset" href="#Gap.inset" class=anchor><b>fn:inset</b></a><span class=code>(i, values, rmlen) -&gt; rm?</span><br>
  
  See ds.inset for documentation.</li>
  <li><a id="Gap.extend" href="#Gap.extend" class=anchor><b>fn:extend</b></a><span class=code>(lns) -&gt; self</span><br>
  
  Extend gap with the lines.</li>
  <li><a id="Gap.setGap" href="#Gap.setGap" class=anchor><b>fn:setGap</b></a><span class=code>(l)</span><br>
  
  set the gap to the line number, making <span class=code>l == #g.bot</span>.</li>
  <li><a id="Gap.write" href="#Gap.write" class=anchor><b>fn:write</b></a><span class=code>(...)</span></li>
  <li><a id="Gap.dumpf" href="#Gap.dumpf" class=anchor><b>fn dumpf</b></a><span class=code>(t, f, close, chunk)</span><br>
  
  write lines <span class=code>t</span> to file <span class=code>f</span> in chunks (default = 16KiB)
  if f is a string then it is opened as a file and closed when done</li>
</ul>

<p><h4><a id="lines.U3File" href="#lines.U3File" class=anchor>Record lines.U3File</h4></a>
A file of 3 byte (24 bit) integers. These are commonly
used for indexing lines.

<p>This object supports get/set index operations including appending. Every
operation (except consecutive reads/writes) requires a file seek.

<p><b>Fields:</b><ul>
  <li><a id="lines.U3File.f" href="#lines.U3File.f" class=anchor><b>f</b></a></li>
  <li><a id="lines.U3File.path" href="#lines.U3File.path" class=anchor><b>path</b></a></li>
  <li><a id="lines.U3File.mode" href="#lines.U3File.mode" class=anchor><b>mode</b></a></li>
  <li><a id="lines.U3File.len" href="#lines.U3File.len" class=anchor><b>len</b></a></li>
  <li><a id="lines.U3File.sz" href="#lines.U3File.sz" class=anchor><b>sz</b></a>
  the size of each value</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="lines.U3File.create" href="#lines.U3File.create" class=anchor><b>fn create</b></a><span class=code>(T, ...) -&gt; icreate(T, 3, ...)</span></li>
  <li><a id="lines.U3File.reload" href="#lines.U3File.reload" class=anchor><b>fn:reload</b></a><span class=code>() -&gt; IFile?, errmsg?</span><br>
  
  Reload IFile from path.</li>
  <li><a id="lines.U3File.load" href="#lines.U3File.load" class=anchor><b>fn load</b></a><span class=code>(T, ...) -&gt; iload(T, 3, ...)</span></li>
  <li><a id="lines.U3File.flush" href="#lines.U3File.flush" class=anchor><b>fn:flush</b></a><span class=code>()</span></li>
  <li><a id="lines.U3File.close" href="#lines.U3File.close" class=anchor><b>fn:close</b></a><span class=code>()</span></li>
  <li><a id="lines.U3File.closed" href="#lines.U3File.closed" class=anchor><b>fn:closed</b></a><span class=code>() -&gt; bool</span></li>
  <li><a id="lines.U3File.getbytes" href="#lines.U3File.getbytes" class=anchor><b>fn:getbytes</b></a><span class=code>(i)</span><br>
  
  get bytes. If index out of bounds return nil.
  Panic if there are read errors.</li>
  <li><a id="lines.U3File.get" href="#lines.U3File.get" class=anchor><b>fn:get</b></a><span class=code>(i)</span><br>
  
  get value at index</li>
  <li><a id="lines.U3File.setbytes" href="#lines.U3File.setbytes" class=anchor><b>fn:setbytes</b></a><span class=code>(i, v)</span></li>
  <li><a id="lines.U3File.set" href="#lines.U3File.set" class=anchor><b>fn:set</b></a><span class=code>(i, v)</span><br>
  
  set value at index</li>
  <li><a id="lines.U3File.move" href="#lines.U3File.move" class=anchor><b>fn:move</b></a><span class=code>(to, mvFn) -&gt; self</span><br>
  
  Move the IFile's path to <span class=code>to</span>.
  
  <p><span class=code>mv</span> must be of type <span class=code>fn(from, to)</span>. If not provided,
  <span class=code>civix.mv</span> will be used.
  
  <p>This can be done on both closed and opened files.
  
  <p>The IFile will re-open on the new file regardless of the
  previous state.</li>
  <li><a id="lines.U3File.reader" href="#lines.U3File.reader" class=anchor><b>fn:reader</b></a><span class=code>() -&gt; IFile?, err?</span><br>
  
  Get a new read-only instance with an independent file-descriptor.
  
  <p>Warning: currently the reader's len will be static, so this should
  be mostly used for temporary cases. This might be changed in
  the future.</li>
</ul>

<p><h4><a id="File" href="#File" class=anchor>Record File</h4></a>
Usage: <span class=code>File{'path/to/file.txt', mode='r'}</span><br>

Indexed file of lines supporting modes 'r' and 'a+'.

<p><div class=info>use EdFile instead if you need to do non-append edits</div>

<p><b>Fields:</b><ul>
  <li><a id="File.path" href="#File.path" class=anchor><b>path</b></a>
  path of this file.</li>
  <li><a id="File.mode" href="#File.mode" class=anchor><b>mode</b></a>
  'r', 'a' or 'a+'</li>
  <li><a id="File.f" href="#File.f" class=anchor><b>f</b></a>
  open (normal) file object</li>
  <li><a id="File.idx" href="#File.idx" class=anchor><b>idx</b></a>
  line index of f</li>
  <li><a id="File.cache" href="#File.cache" class=anchor><b>cache</b></a>
  cache of lines</li>
  <li><a id="File.loadIdxFn" href="#File.loadIdxFn" class=anchor><b>loadIdxFn</b></a>
  default=lines.futils.loadIdx</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="File.close" href="#File.close" class=anchor><b>fn:close</b></a><span class=code>()</span></li>
  <li><a id="File.flush" href="#File.flush" class=anchor><b>fn:flush</b></a><span class=code>() -&gt; ok, errmsg?</span></li>
  <li><a id="File.write" href="#File.write" class=anchor><b>fn:write</b></a><span class=code>(...) -&gt; ok, errmsg?</span><br>
  
  append to file</li>
  <li><a id="File.get" href="#File.get" class=anchor><b>fn:get</b></a><span class=code>(i) -&gt; line</span><br>
  
  Get line at index</li>
  <li><a id="File.set" href="#File.set" class=anchor><b>fn:set</b></a><span class=code>(i, v)</span><br>
  
  Set line at index</li>
  <li><a id="File.reader" href="#File.reader" class=anchor><b>fn:reader</b></a><span class=code>() -&gt; lines.File?, err?</span><br>
  
  Get a new read-only instance with an independent file-descriptor.
  
  <p>This allows reading the file while another coroutine writes it (via
  <a href="lap.html">lap.html</a>).</li>
</ul>

<p><h4><a id="EdFile" href="#EdFile" class=anchor>Record EdFile</h4></a>
EdFile: an editable line-based file object, optimized for
indexed and consequitive reads and writes

<p><b>Usage:</b><div class=code-block>local ed = EdFile(path, mode);<br>
ed:set(1, 'first line')<br>
ed:set(2, 'second line')<br>
ed:set(1, 'changed first line')<br>
ed:close()
</div>

<p><b>Fields:</b><ul>
  <li><a id="EdFile.lf" href="#EdFile.lf" class=anchor><b>lf</b></a>
  indexed append-only file.</li>
  <li><a id="EdFile.dats" href="#EdFile.dats" class=anchor><b>dats</b></a>
  list of Slc | Gap objects.</li>
  <li><a id="EdFile.lens" href="#EdFile.lens" class=anchor><b>lens</b></a>
  rolling sum of dat lengths.</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="EdFile.get" href="#EdFile.get" class=anchor><b>fn:get</b></a><span class=code>(i) -&gt; line</span><br>
  
  Get line at index</li>
  <li><a id="EdFile.write" href="#EdFile.write" class=anchor><b>fn:write</b></a><span class=code>(...) -&gt; self?, errmsg?</span></li>
  <li><a id="EdFile.set" href="#EdFile.set" class=anchor><b>fn:set</b></a><span class=code>(i, v)</span><br>
  
  Set line at index.</li>
  <li><a id="EdFile.reader" href="#EdFile.reader" class=anchor><b>fn:reader</b></a><span class=code>()</span><br>
  
  Return a read-only view of the EdFile which shares the
  associated data structures.</li>
  <li><a id="EdFile.flush" href="#EdFile.flush" class=anchor><b>fn:flush</b></a><span class=code>()</span><br>
  
  Flush the .lf member (which can only be extended).
  To write all data to disk you must call <span class=code>:dumpf()</span>.</li>
  <li><a id="EdFile.close" href="#EdFile.close" class=anchor><b>fn:close</b></a><span class=code>()</span><br>
  
  Note: to write all data to disk you must call <span class=code>:dumpf()</span>.</li>
  <li><a id="EdFile.dumpf" href="#EdFile.dumpf" class=anchor><b>fn:dumpf</b></a><span class=code>(f)</span><br>
  
  Dump contents to file or path.</li>
  <li><a id="EdFile.extend" href="#EdFile.extend" class=anchor><b>fn:extend</b></a><span class=code>(values)</span><br>
  
  Appends to lf for extend when possible.</li>
  <li><a id="EdFile.inset" href="#EdFile.inset" class=anchor><b>fn:inset</b></a><span class=code>(i, values, rmlen) -&gt; rm?</span><br>
  
  insert into EdFile's dats.</li>
</ul>

<p><h3><a id="lines.futils" href="#lines.futils" class=anchor>Mod lines.futils</h3></a>
utilities for file loading of lines. Generally users shouldn't

<p>need to use this file.

<p><b>Functions</b> <ul>
  <li><a id="lines.futils.forceLoadIdx" href="#lines.futils.forceLoadIdx" class=anchor><b>fn forceLoadIdx</b></a><span class=code>(f, idxpath)</span><br>
  
  Can be usd instead of loadIdx to force a reload of the index,
  ignoring modification times/etc.
  
  <p>This is useful in some situtations where stat is not available.</li>
  <li><a id="lines.futils.loadIdx" href="#lines.futils.loadIdx" class=anchor><b>fn loadIdx</b></a><span class=code>(f, idxpath, fmode, reindex) -&gt; idxFile</span><br>
  
  load or reindex the file at path to/from idxpath.</li>
</ul>

<p><h3><a id="lines.motion" href="#lines.motion" class=anchor>Mod lines.motion</h3></a>
Helper methods for moving a cursor around a lines-like 2D grid.

<p>The notation <span class=code>l.c</span> is used to refer to line, column where

<p>both are indexed by 1.

<p><b>Functions</b> <ul>
  <li><a id="lines.motion.decDistance" href="#lines.motion.decDistance" class=anchor><b>fn decDistance</b></a><span class=code>(s, e) -&gt; int</span><br>
  
  Move <span class=code>s</span> closer to <span class=code>e</span> by 1.<br>
  
  If they are equal do nothing.</li>
  <li><a id="lines.motion.lcLe" href="#lines.motion.lcLe" class=anchor><b>fn lcLe</b></a><span class=code>(l, c, l2, c2) -&gt; bool</span><br>
  
  Return whether <span class=code>l.c</span> is equal to or before <span class=code>l2.c2</span>.</li>
  <li><a id="lines.motion.lcGe" href="#lines.motion.lcGe" class=anchor><b>fn lcGe</b></a><span class=code>(l, c, l2, c2) -&gt; bool</span><br>
  
  Return whether <span class=code>l.c</span> is equal to or after <span class=code>l2.c2</span></li>
  <li><a id="lines.motion.topLeft" href="#lines.motion.topLeft" class=anchor><b>fn topLeft</b></a><span class=code>(l, c, l2, c2) -&gt; (l, c)</span><br>
  
  Return the top-left (aka the minimum) of two points.</li>
  <li><a id="lines.motion.lcWithin" href="#lines.motion.lcWithin" class=anchor><b>fn lcWithin</b></a><span class=code>(l, c, l1, c1, l2, c2) -&gt; bool</span></li>
  <li><a id="lines.motion.wordKind" href="#lines.motion.wordKind" class=anchor><b>fn wordKind</b></a><span class=code>(ch) -&gt; ws|sym|let</span><br>
  
  Given a character, return it's word-kind:
  ws (whitespace), sym (symbol), let (letter).</li>
  <li><a id="lines.motion.pathKind" href="#lines.motion.pathKind" class=anchor><b>fn pathKind</b></a><span class=code>(ch) -&gt; ws|sym|path</span><br>
  
  Given a character, return it's path-kind:
  ws (whitespace), sym (symbol), path (path)</li>
  <li><a id="lines.motion.forword" href="#lines.motion.forword" class=anchor><b>fn forword</b></a><span class=code>(s, si, getKind) -&gt; int</span><br>
  
  Get the start of the next word from si (start-index).</li>
  <li><a id="lines.motion.backword" href="#lines.motion.backword" class=anchor><b>fn backword</b></a><span class=code>(s, ei, getKind) -&gt; int</span><br>
  
  Get the start of the previous word from ei (end-index).</li>
  <li><a id="lines.motion.getRange" href="#lines.motion.getRange" class=anchor><b>fn getRange</b></a><span class=code>(s, i, getKind) -&gt; si,ei</span><br>
  
  get the <span class=code>range[si,ei]</span> of whatever is at <span class=code>s[i]</span>.</li>
  <li><a id="lines.motion.findBack" href="#lines.motion.findBack" class=anchor><b>fn findBack</b></a><span class=code>(s, pat, ei, plain) -&gt; int</span><br>
  
  find backwards from ei (end index).<br>
  
  This searches for the pattern and returns the LAST one found.
  This is HORRIBLY non-performant, only use for small amounts of data (like a
  line).</li>
</ul>

<p><b>table</b>: raw <span class=code>table</span>

<p><h3><a id="lines.kev" href="#lines.kev" class=anchor>Mod lines.kev</h3></a>
kev: "Key Equal Value" serialization format.

<p>
<p>
<p>This is an extremely common format in many unix utilities, "good enough"

<p>for a large number of configuration use cases. The format is simple: a file

<p>containing lines of <span class=code>key=value</span>. The input and output are a table of

<p>key,val strings (though tostring is called for <span class=code>to()</span>). Lines which start

<p>with <span class=code>#</span> or don't have <span class=code>=</span> in them are ignored.

<p>
<p>
<p>Nested data is absolutely not supported. Spaces are treated as literal both

<p>before and after <span class=code>=</span>. If you want a key containing <span class=code>=</span> or key/value

<p>containing newline then use a different format (or write your own).

<p><b>Functions</b> <ul>
  <li><a id="lines.kev.to" href="#lines.kev.to" class=anchor><b>fn to</b></a><span class=code>(t)</span><br>
  
  convert to a table of <span class=code>key=value</span> lines.</li>
  <li><a id="lines.kev.from" href="#lines.kev.from" class=anchor><b>fn from</b></a><span class=code>(lines, to)</span><br>
  
  convert <span class=code>key=value</span> lines to a table.</li>
  <li><a id="lines.kev.load" href="#lines.kev.load" class=anchor><b>fn load</b></a><span class=code>(f)</span></li>
  <li><a id="lines.kev.dump" href="#lines.kev.dump" class=anchor><b>fn dump</b></a><span class=code>(t)</span></li>
</ul>

<p>
</div></body>
</html>
