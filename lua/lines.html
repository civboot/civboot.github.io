<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1>lines: view files as list of lines</h1>
The <span class=code>lines</span> library (and it's submodules) enable line-based processing of
text. The <a href="#lines">#lines</a> module itself exports an API that work on both a list of
strings (aka lines) or deal with files as indexed lines (i.e. <a href="#lines.File">#lines.File</a>)
<br>
<br>
<span class=code>lines</span> is the fundamental building block of civstack's <a href="ele.html">ele</a> editor
and <a href="cxt.html">pegl></a> parsers: it is much easier as a developer to think about
human-readable text as a list of lines then as a list of bytes and this is
especially true for an editor. <a href="#lines.File">#lines.File</a> and <a href="#lines.EdFile">#lines.EdFile</a> use
a separate index file to make reading and writing to files as lines
actually performant for more real-world use-cases.
<br>
<h3><a id="lines" href="#lines" class=anchor>Mod lines</h3></a>
The lines module, providing a uniform API for lines-like objects.
<br>
<div class=info>You can also call this module directly to get a table of lines
from a string</div>
<b>Functions</b> <ul>
  <li><a id="lines.join" href="#lines.join" class=anchor><b>fn join</b></a><span class=code>(t) -&gt; string</span><br>
  
  Join a table of strings with newlines.</li>
  <li><a id="lines.insert" href="#lines.insert" class=anchor><b>fn insert</b></a><span class=code>(t, s, l,c) -&gt; nil</span><br>
  
  insert string at l, c<br>
  
  
  Note: this is NOT performant (O(N)) for large tables.<br>
  
  See: <a href="#Gap">#Gap</a> (or similar) for handling real-world workloads.</li>
  <li><a id="lines.span" href="#lines.span" class=anchor><b>fn span</b></a><span class=code>(l, c, l2, c2) -&gt; (l, c?, l2, c2?)</span><br>
  
  Enables addressing lines via either (l,l2) or (l,c, l2,c2) span.</li>
  <li><a id="lines.sort" href="#lines.sort" class=anchor><b>fn sort</b></a><span class=code>(...) -&gt; l1, c1, l2, c2</span><br>
  
  sort the span</li>
  <li><a id="lines.sub" href="#lines.sub" class=anchor><b>fn sub</b></a><span class=code>(l, ...) -&gt; string | table</span><br>
  
  Get the sub-span of the lines.<br>
  
  Returns a string if the result is a single line, else a table of lines.</li>
  <li><a id="lines.usub" href="#lines.usub" class=anchor><b>fn usub</b></a><span class=code>(l, ...) -&gt; string | table</span><br>
  
  Get the UTF8 aware sub-span of the lines.<br>
  
  Returns a string if the result is a single line, else a table of lines.</li>
  <li><a id="lines.map" href="#lines.map" class=anchor><b>fn map</b></a><span class=code>(lines) -&gt; table</span><br>
  
  create a table of lineText -> {lineNums}</li>
  <li><a id="lines.bound" href="#lines.bound" class=anchor><b>fn bound</b></a><span class=code>(t, l, c, len, line) -&gt; l, c</span><br>
  
  bound the line/col for the lines table.
  This will automatically convert negatives indexes to positive,
  where <span class=code>-1</span> is the last item.</li>
  <li><a id="lines.offset" href="#lines.offset" class=anchor><b>fn offset</b></a><span class=code>(t, off, l, c) -&gt; l, c</span><br>
  
  Get the <span class=code>l, c</span> with the +/- offset applied</li>
  <li><a id="lines.offsetOf" href="#lines.offsetOf" class=anchor><b>fn offsetOf</b></a><span class=code>(t, l, c, l2, c2) -&gt; int</span><br>
  
  get the byte offset </li>
  <li><a id="lines.find" href="#lines.find" class=anchor><b>fn find</b></a><span class=code>(t, pat, l, c) -&gt; (l, c, c2)</span><br>
  
  find the pattern starting at l/c
  Note: matches are only within a single line.</li>
  <li><a id="lines.findBack" href="#lines.findBack" class=anchor><b>fn findBack</b></a><span class=code>(t, pat, l, c)</span><br>
  
  find the pattern (backwards) starting at l/c</li>
  <li><a id="lines.remove" href="#lines.remove" class=anchor><b>fn remove</b></a><span class=code>(t, ...) -&gt; string|table</span><br>
  
  remove span (l, c) -> (l2, c2), return what was removed</li>
  <li><a id="lines.box" href="#lines.box" class=anchor><b>fn box</b></a><span class=code>(t, l1, c1, l2, c2, fill) -&gt; lines</span><br>
  
  return the box of the lines.
  
  <div class=code-block>Outside the box is not returned.<br>
***1------------------------+**<br>
***|l1,c1 = top left &nbsp; &nbsp; &nbsp; &nbsp;|**<br>
***| &nbsp; &nbsp; &nbsp; bot right = l2,c2|<br>
***+------------------------2**<br>
*So no '*' chars are returned.*
</div></li>
  <li><a id="lines.load" href="#lines.load" class=anchor><b>fn load</b></a><span class=code>(f, close) -&gt; (table?, errstr?)</span><br>
  
  load lines from file or path. On error return (nil, errstr)</li>
  <li><a id="lines.dump" href="#lines.dump" class=anchor><b>fn dump</b></a><span class=code>(t, f, close, chunk)</span><br>
  
  write lines <span class=code>t</span> to file <span class=code>f</span> in chunks (default = 16KiB)
  if f is a string then it is opened as a file and closed when done</li>
  <li><a id="lines.write" href="#lines.write" class=anchor><b>fn write</b></a><span class=code>(t, ...) -&gt; true</span><br>
  
  Logic to make a table behave like a <span class=code>file:write(...)</span> method.
  
  This is NOT performant, especially for large lines.</li>
</ul>
<br>
<h4><a id="lines.diff" href="#lines.diff" class=anchor>Command lines.diff</h4></a>
Diffing module and command<br>

Cmd Usage: <span class=code>ldiff 'file/path1.txt' 'file/path2.txt'</span><br>

Lib Usage: <span class=code>io.fmt(ldiff.Diff(linesA, linesB))</span><br>

<br>
This library/cmd creates readable diffs using the "patience diff" alorithm.
The code was written from scratch referencing only the algorithm outline
below, but I want to give special thanks to James Coglan for his
<a href="https://blog.jcoglan.com/2017/09/19/the-patience-diff-algorithm">
excellent blog post</a>.
<br>
<br>
Fundamentals of patience diff: <ul>
  <li>Skip unchanged lines on both top and bottom.</li>
  <li>Find unique lines in both sets and "align" them using "longest increasing
  sequence".</li>
  <li>Repeat for each aligned section.</li>
</ul>
<br>
<b>Types: </b><a href="#lines.diff.Diff">Diff</a> 
<br>
<br>
<h4><a id="lines.diff.Diff" href="#lines.diff.Diff" class=anchor>Record Diff</h4></a>
Datastructure which holds the result of computing the difference
between two lists of lines.<br>

<br>
Fields <span class=code>b</span> and <span class=code>c</span> are just the original base/change lines.
<br>
<span class=code>noc</span>, <span class=code>rem</span> and <span class=code>add</span> are lists of integers which represent the length
of a block. For instance, if for a given index <span class=code>rem=3</span> and <span class=code>add=2</span> it
means that three lines were removed from <span class=code>b</span> and two were added to
<span class=code>c</span>. If <span class=code>noc=10</span> that means that there is a block of 10 identical lines.
<br>
<b>Fields:</b><ul>
  <li><a id="lines.diff.Diff.b" href="#lines.diff.Diff.b" class=anchor><b>b</b></a>
  base, aka raw original lines</li>
  <li><a id="lines.diff.Diff.c" href="#lines.diff.Diff.c" class=anchor><b>c</b></a>
  change, aka raw new lines</li>
  <li><a id="lines.diff.Diff.len" href="#lines.diff.Diff.len" class=anchor><b>len</b></a>
  len of diff blocks (aka len of below fields).
  It's not possible to use # for below, since some values
  are nil.</li>
  <li><a id="lines.diff.Diff.noc" href="#lines.diff.Diff.noc" class=anchor><b>noc</b></a>
  nochange range (in both)</li>
  <li><a id="lines.diff.Diff.rem" href="#lines.diff.Diff.rem" class=anchor><b>rem</b></a>
  removed from b</li>
  <li><a id="lines.diff.Diff.add" href="#lines.diff.Diff.add" class=anchor><b>add</b></a>
  added from c</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Diff.map" href="#Diff.map" class=anchor><b>fn:map</b></a><span class=code>(nocFn, chgFn)</span><br>
  
  Iterate through nochange and change blocks, calling the functions for each
  <ul>
    <li><span class=code>nocFn(baseStart, numUnchanged, changeStart, numUnchanged)</span></li>
    <li><span class=code>chgFn(baseStart, numRemoved, &nbsp; changeStart, numAdded)</span></li>
  </ul>
  Note that the num removed/added will be nil if none were added/removed.</li>
</ul>
<br>
<h4><a id="lines.Writer" href="#lines.Writer" class=anchor>Record lines.Writer</h4></a>
<b>Deprecated: use ds.bytearray instead. This will be removed.</b>
<br>
A lines table with a write method and a few other file-like methods.
This is NOT performant, especially for small writes or large lines. It is
useful for tests and cases where simplicity is more important than
performance.
<br>
<b>Methods</b> <ul>
  <li><a id="lines.Writer.set" href="#lines.Writer.set" class=anchor><b>fn set</b></a><span class=code>(name)</span><br>
  
  Create a parser spec record. These have the fields <span class=code>kind</span> and <span class=code>name</span>
  and must define the <span class=code>parse</span> method.</li>
  <li><a id="lines.Writer.get" href="#lines.Writer.get" class=anchor><b>fn get</b></a><span class=code>(name)</span><br>
  
  Create a parser spec record. These have the fields <span class=code>kind</span> and <span class=code>name</span>
  and must define the <span class=code>parse</span> method.</li>
  <li><a id="lines.Writer.write" href="#lines.Writer.write" class=anchor><b>fn write</b></a><span class=code>(t, ...) -&gt; true</span><br>
  
  Logic to make a table behave like a <span class=code>file:write(...)</span> method.
  
  This is NOT performant, especially for large lines.</li>
  <li><a id="lines.Writer.flush" href="#lines.Writer.flush" class=anchor><b>fn flush</b></a><span class=code>()</span><br>
  
  function that does and returns nothing.</li>
  <li><a id="lines.Writer.extend" href="#lines.Writer.extend" class=anchor><b>fn extend</b></a><span class=code>(r, l) -&gt; r</span><br>
  
  This is used by types implementing <span class=code>:extend</span>.
  It uses their <span class=code>get</span> and <span class=code>set</span> methods to implement
  extend in a for loop.
  
  <div class=info>types do this if they may <span class=code>yield</span> in their get/set, which
  is not allowed through a C boundary like <span class=code>table.move</span></div></li>
  <li><a id="lines.Writer.icopy" href="#lines.Writer.icopy" class=anchor><b>fn icopy</b></a><span class=code>(r)</span><br>
  
  For types implementing <span class=code>:copy()</span> method.</li>
</ul>
<br>
<h4><a id="Gap" href="#Gap" class=anchor>Record Gap</h4></a>
Line-based gap buffer. The buffer is composed of two lists (stacks) of
lines <ul>
  <li>The "bot" (aka bottom) contains line 1 -> curLine.
  curLine is at #bot. Data gets added to bot.</li>
  <li>The "top" buffer is used to store data in lines
  after "bot" (aka after curLine). If the cursor is
  moved to a previous line then data is moved from top to bot</li>
</ul>
<br>
<div class=info>Gap gives a file-like write API which may not be the most performant
for some workloads (writing single characters)</div>
<br>
<b>Fields:</b><ul>
  <li><a id="Gap.top" href="#Gap.top" class=anchor><b>top</b></a>
  array of lines on the top (near start).</li>
  <li><a id="Gap.bot" href="#Gap.bot" class=anchor><b>bot</b></a>
  array of lines on the bottom (near end).</li>
  <li><a id="Gap.path" href="#Gap.path" class=anchor><b>path</b></a>
  the path this was read from or nil.</li>
  <li><a id="Gap.readonly" href="#Gap.readonly" class=anchor><b>readonly</b></a>
  whether to throw errors on write.</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Gap.icopy" href="#Gap.icopy" class=anchor><b>fn:icopy</b></a><span class=code>() -&gt; list</span><br>
  
  Make a copy of the gap to a lua list.</li>
  <li><a id="Gap.load" href="#Gap.load" class=anchor><b>fn load</b></a><span class=code>(T, f, close) -&gt; Gap?, err?</span><br>
  
  Load gap from file, which can be a path.
  returns <span class=code>nil, err</span> on error</li>
  <li><a id="Gap.get" href="#Gap.get" class=anchor><b>fn:get</b></a><span class=code>(l) -&gt; string</span><br>
  
  Get a specific line index.</li>
  <li><a id="Gap.set" href="#Gap.set" class=anchor><b>fn:set</b></a><span class=code>(l, v)</span><br>
  
  Set a specific line index with the value.</li>
  <li><a id="Gap.inset" href="#Gap.inset" class=anchor><b>fn:inset</b></a><span class=code>(i, values, rmlen) -&gt; rm?</span><br>
  
  See ds.inset for documentation.</li>
  <li><a id="Gap.extend" href="#Gap.extend" class=anchor><b>fn:extend</b></a><span class=code>(lns) -&gt; self</span><br>
  
  Extend gap with the lines.</li>
  <li><a id="Gap.setGap" href="#Gap.setGap" class=anchor><b>fn:setGap</b></a><span class=code>(l)</span><br>
  
  set the gap to the line number, making <span class=code>l == #g.bot</span>.</li>
  <li><a id="Gap.write" href="#Gap.write" class=anchor><b>fn:write</b></a><span class=code>(...)</span></li>
  <li><a id="Gap.dumpf" href="#Gap.dumpf" class=anchor><b>fn dumpf</b></a><span class=code>(t, f, close, chunk)</span><br>
  
  write lines <span class=code>t</span> to file <span class=code>f</span> in chunks (default = 16KiB)
  if f is a string then it is opened as a file and closed when done</li>
</ul>
<br>
<h4><a id="lines.U3File" href="#lines.U3File" class=anchor>Record lines.U3File</h4></a>
A file of 3 byte (24 bit) integers. These are commonly
used for indexing lines.
<br>
This object supports get/set index operations including appending. Every
operation (except consecutive reads/writes) requires a file seek.
<br>
<b>Fields:</b><ul>
  <li><a id="lines.U3File.f" href="#lines.U3File.f" class=anchor><b>f</b></a></li>
  <li><a id="lines.U3File.path" href="#lines.U3File.path" class=anchor><b>path</b></a></li>
  <li><a id="lines.U3File.mode" href="#lines.U3File.mode" class=anchor><b>mode</b></a></li>
  <li><a id="lines.U3File.len" href="#lines.U3File.len" class=anchor><b>len</b></a></li>
  <li><a id="lines.U3File.sz" href="#lines.U3File.sz" class=anchor><b>sz</b></a>
  the size of each value</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="lines.U3File.create" href="#lines.U3File.create" class=anchor><b>fn create</b></a><span class=code>(T, ...) -&gt; icreate(T, 3, ...)</span></li>
  <li><a id="lines.U3File.reload" href="#lines.U3File.reload" class=anchor><b>fn reload</b></a><span class=code>(fi) -&gt; IFile?, errmsg?</span><br>
  
  Reload IFile from path.</li>
  <li><a id="lines.U3File.load" href="#lines.U3File.load" class=anchor><b>fn load</b></a><span class=code>(T, ...) -&gt; iload(T, 3, ...)</span></li>
  <li><a id="lines.U3File.flush" href="#lines.U3File.flush" class=anchor><b>fn flush</b></a><span class=code>(fi) -&gt; fi.f:flush()</span></li>
  <li><a id="lines.U3File.close" href="#lines.U3File.close" class=anchor><b>fn close</b></a><span class=code>(fi)</span></li>
  <li><a id="lines.U3File.closed" href="#lines.U3File.closed" class=anchor><b>fn closed</b></a><span class=code>(fi) -&gt; bool</span></li>
  <li><a id="lines.U3File.getbytes" href="#lines.U3File.getbytes" class=anchor><b>fn getbytes</b></a><span class=code>(fi, i)</span><br>
  
  get bytes. If index out of bounds return nil.
  Panic if there are read errors.</li>
  <li><a id="lines.U3File.get" href="#lines.U3File.get" class=anchor><b>fn:get</b></a><span class=code>(i)</span><br>
  
  get value at index</li>
  <li><a id="lines.U3File.setbytes" href="#lines.U3File.setbytes" class=anchor><b>fn setbytes</b></a><span class=code>(fi, i, v)</span></li>
  <li><a id="lines.U3File.set" href="#lines.U3File.set" class=anchor><b>fn:set</b></a><span class=code>(i, v)</span><br>
  
  set value at index</li>
  <li><a id="lines.U3File.move" href="#lines.U3File.move" class=anchor><b>fn move</b></a><span class=code>(fi, to, mvFn) -&gt; fi</span><br>
  
  Move the IFile's path to <span class=code>to</span>.
  
  <span class=code>mv</span> must be of type <span class=code>fn(from, to)</span>. If not provided,
  <span class=code>civix.mv</span> will be used.
  
  This can be done on both closed and opened files.
  
  The IFile will re-open on the new file regardless of the
  previous state.</li>
  <li><a id="lines.U3File.reader" href="#lines.U3File.reader" class=anchor><b>fn reader</b></a><span class=code>(fi) -&gt; IFile?, err?</span><br>
  
  Get a new read-only instance with an independent file-descriptor.
  
  Warning: currently the reader's len will be static, so this should
  be mostly used for temporary cases. This might be changed in
  the future.</li>
</ul>
<br>
<h4><a id="File" href="#File" class=anchor>Record File</h4></a>
Usage: <span class=code>File{path='path/to/file.txt', mode='r'}</span><br>

Indexed file of lines supporting read and append.
<br>
<div class=info>use EdFile instead if you need to do non-append edits</div>
<br>
<b>Fields:</b><ul>
  <li><a id="File.path" href="#File.path" class=anchor><b>path</b></a>
  path of this file.</li>
  <li><a id="File.mode" href="#File.mode" class=anchor><b>mode</b></a>
  'r', 'a' or 'a+'</li>
  <li><a id="File.f" href="#File.f" class=anchor><b>f</b></a>
  open (normal) file object</li>
  <li><a id="File.idx" href="#File.idx" class=anchor><b>idx</b></a>
  line index of f</li>
  <li><a id="File.cache" href="#File.cache" class=anchor><b>cache</b></a>
  cache of lines</li>
  <li><a id="File.loadIdxFn" href="#File.loadIdxFn" class=anchor><b>loadIdxFn</b></a>
  default=lines.futils.loadIdx</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="File.close" href="#File.close" class=anchor><b>fn:close</b></a><span class=code>()</span></li>
  <li><a id="File.flush" href="#File.flush" class=anchor><b>fn:flush</b></a><span class=code>() -&gt; ok, errmsg?</span></li>
  <li><a id="File.write" href="#File.write" class=anchor><b>fn:write</b></a><span class=code>(...) -&gt; ok, errmsg?</span><br>
  
  append to file</li>
  <li><a id="File.get" href="#File.get" class=anchor><b>fn:get</b></a><span class=code>(i) -&gt; line</span><br>
  
  Get line at index</li>
  <li><a id="File.set" href="#File.set" class=anchor><b>fn:set</b></a><span class=code>(i, v)</span><br>
  
  Set line at index</li>
  <li><a id="File.reader" href="#File.reader" class=anchor><b>fn:reader</b></a><span class=code>() -&gt; lines.File?, err?</span><br>
  
  Get a new read-only instance with an independent file-descriptor.
  
  This allows reading the file while another coroutine writes it (via
  <a href="lap.html">lap.html</a>).</li>
</ul>
<br>
<h4><a id="Ty<EdFile>" href="#Ty<EdFile>" class=anchor>Record EdFile</h4></a>
<b>Fields:</b><ul>
  <li><a id="Ty<EdFile>.lf" href="#Ty<EdFile>.lf" class=anchor><b>lf</b></a>
  indexed file</li>
  <li><a id="Ty<EdFile>.dats" href="#Ty<EdFile>.dats" class=anchor><b>dats</b></a>
  list of Slc | Gap</li>
  <li><a id="Ty<EdFile>.lens" href="#Ty<EdFile>.lens" class=anchor><b>lens</b></a>
  rolling sum of dat lengths</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="EdFile.get" href="#EdFile.get" class=anchor><b>fn get</b></a><span class=code>(ef, i) -&gt; line</span><br>
  
  Get line at index</li>
  <li><a id="EdFile.write" href="#EdFile.write" class=anchor><b>fn write</b></a><span class=code>(ef, ...) -&gt; self?, errmsg?</span></li>
  <li><a id="EdFile.set" href="#EdFile.set" class=anchor><b>fn set</b></a><span class=code>(ef, i, v)</span><br>
  
  Set line at index.</li>
  <li><a id="EdFile.reader" href="#EdFile.reader" class=anchor><b>fn reader</b></a><span class=code>(ef)</span><br>
  
  Return a read-only view of the EdFile which shares the
  associated data structures.</li>
  <li><a id="EdFile.flush" href="#EdFile.flush" class=anchor><b>fn flush</b></a><span class=code>(ef) -&gt; ef.lf:flush()</span><br>
  
  Flush the .lf member (which can only be extended).
  To write all data to disk use :dumpf()</li>
  <li><a id="EdFile.close" href="#EdFile.close" class=anchor><b>fn close</b></a><span class=code>(ef) -&gt; ef.lf:close()</span><br>
  
  Note: this does NOT necessarily flush what you expect.</li>
  <li><a id="EdFile.dumpf" href="#EdFile.dumpf" class=anchor><b>fn dumpf</b></a><span class=code>(ef, f)</span><br>
  
  Dump EdFile to file or path</li>
  <li><a id="EdFile.extend" href="#EdFile.extend" class=anchor><b>fn extend</b></a><span class=code>(ef, values)</span><br>
  
  appends to lf for extend when possible.</li>
  <li><a id="EdFile.inset" href="#EdFile.inset" class=anchor><b>fn inset</b></a><span class=code>(ef, i, values, rmlen) -&gt; rm?</span><br>
  
  insert into EdFile's dats.</li>
</ul>
<br>
<h3><a id="lines.futils" href="#lines.futils" class=anchor>Mod lines.futils</h3></a>
utilities for file loading of lines.
<b>Functions</b> <ul>
  <li><a id="lines.futils.forceLoadIdx" href="#lines.futils.forceLoadIdx" class=anchor><b>fn forceLoadIdx</b></a><span class=code>(f, idxpath)</span><br>
  
  Can be usd instead of loadIdx to force a reload of the index,
  ignoring modification times/etc.
  
  This is useful in some situtations where stat is not available.</li>
  <li><a id="lines.futils.loadIdx" href="#lines.futils.loadIdx" class=anchor><b>fn loadIdx</b></a><span class=code>(f, idxpath, fmode, reindex) -&gt; idxFile</span><br>
  
  load or reindex the file at path to/from idxpath.</li>
</ul>
<br>
<h3><a id="lines.motion" href="#lines.motion" class=anchor>Mod lines.motion</h3></a>
module with helper methods for moving a cursor
around a lines-like 2D grid.
<b>Functions</b> <ul>
  <li><a id="lines.motion.decDistance" href="#lines.motion.decDistance" class=anchor><b>fn decDistance</b></a><span class=code>(s, e) -&gt; int</span><br>
  
  decrease distance (start -> end) by 1</li>
  <li><a id="lines.motion.lcLe" href="#lines.motion.lcLe" class=anchor><b>fn lcLe</b></a><span class=code>(l, c, l2, c2) -&gt; bool</span><br>
  
  return whether l.c is <= l2.c2</li>
  <li><a id="lines.motion.lcGe" href="#lines.motion.lcGe" class=anchor><b>fn lcGe</b></a><span class=code>(l, c, l2, c2) -&gt; bool</span><br>
  
  return whether l.c is >= l2.c2</li>
  <li><a id="lines.motion.topLeft" href="#lines.motion.topLeft" class=anchor><b>fn topLeft</b></a><span class=code>(l, c, l2, c2) -&gt; (l, c)</span><br>
  
  return the top-left of two points</li>
  <li><a id="lines.motion.lcWithin" href="#lines.motion.lcWithin" class=anchor><b>fn lcWithin</b></a><span class=code>(l, c, l1, c1, l2, c2) -&gt; bool</span></li>
  <li><a id="lines.motion.wordKind" href="#lines.motion.wordKind" class=anchor><b>fn wordKind</b></a><span class=code>(ch) -&gt; ws|sym|let</span></li>
  <li><a id="lines.motion.pathKind" href="#lines.motion.pathKind" class=anchor><b>fn pathKind</b></a><span class=code>(ch) -&gt; ws|sym|path</span></li>
  <li><a id="lines.motion.forword" href="#lines.motion.forword" class=anchor><b>fn forword</b></a><span class=code>(s, begin, getKind) -&gt; int</span><br>
  
  Go forward to find the start of the next word</li>
  <li><a id="lines.motion.backword" href="#lines.motion.backword" class=anchor><b>fn backword</b></a><span class=code>(s, end_, getKind) -&gt; int</span><br>
  
  Go backward to find the start of this (or previous) word</li>
  <li><a id="lines.motion.getRange" href="#lines.motion.getRange" class=anchor><b>fn getRange</b></a><span class=code>(s, i, getKind) -&gt; si,ei</span><br>
  
  get the <span class=code>range[si,ei]</span> of whatever is at <span class=code>s[i]</span>.</li>
  <li><a id="lines.motion.findBack" href="#lines.motion.findBack" class=anchor><b>fn findBack</b></a><span class=code>(s, pat, end_, plain) -&gt; int</span><br>
  
  find backwards
  this searches for the pattern and returns the LAST one found.
  This is HORRIBLY non-performant, only use for small amounts of data</li>
</ul>
<br>
<b>table</b>: raw <span class=code>table</span>
<br>
<h3><a id="lines.kev" href="#lines.kev" class=anchor>Mod lines.kev</h3></a>
kev: "Key Equal Value" serialization format.
<br>
This is an extremely common format in many unix utilities, "good enough"
for a large number of configuration use cases. The format is simple: a file
containing lines of <span class=code>key=value</span>. The input and output are a table of
key,val strings (though tostring is called for <span class=code>to()</span>). Lines which don't
have <span class=code>=</span> in them are ignored.
<br>
Nested data is absolutely not supported. Spaces are treated as literal both
before and after <span class=code>=</span>. If you want a key containing <span class=code>=</span> or key/value
containing newline then use a different format.
<b>Functions</b> <ul>
  <li><a id="lines.kev.to" href="#lines.kev.to" class=anchor><b>fn to</b></a><span class=code>(t)</span><br>
  
  convert to a table of <span class=code>key=value</span> lines.</li>
  <li><a id="lines.kev.from" href="#lines.kev.from" class=anchor><b>fn from</b></a><span class=code>(lines, to)</span><br>
  
  convert <span class=code>key=value</span> lines to a table.</li>
  <li><a id="lines.kev.load" href="#lines.kev.load" class=anchor><b>fn load</b></a><span class=code>(f, to) -&gt; M.from(lines.load(f), to)</span></li>
  <li><a id="lines.kev.dump" href="#lines.kev.dump" class=anchor><b>fn dump</b></a><span class=code>(t, f) -&gt; lines.dump(M.to(t), f)</span></li>
</ul>
<br>
</div></body>
</html>
