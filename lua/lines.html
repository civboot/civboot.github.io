<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1><a id=""lines"" href="#"lines"">Mod lines</h1></a>
lines module, when called splits a string into lines.
<span class=code>require'lines'(text) -&gt; table of lines</span>
<p>
sub-modules include several data structures with more performant
mechanisms to insert/remove/etc based on real-world workloads
(i.e. editor, parser, etc)
<p>
<h1><a id=""lines.diff"" href="#"lines.diff"">Mod lines.diff</h1></a>
Diffing module and command
Example command: <span class=code>lines.diff{'file/path1.txt', 'file/path2.txt'}</span>
Note: the arguments can be a string (path) or list of lines.
<p>
<b>Types</b> <ul>
  <li><b>lines.diff.Diff</b></li>
</ul>
<p>
<b>Functions</b> <ul>
  <li><span class=code>main(args)</span></li>
</ul>
<p>
<h2><a id=""lines.diff.Diff"" href="#"lines.diff.Diff"">Record Diff</h2></a>
<ul>
  <li><b>b</b> :
  base, aka original lines</li>
  <li><b>c</b> :
  change, aka new lines</li>
  <li><b>di</b> :
  len of noc/rem/add</li>
  <li><b>noc</b> :
  nochange range (in both)</li>
  <li><b>rem</b> :
  removed from b</li>
  <li><b>add</b> :
  added from c</li>
</ul>
Line-based diff.
The default algorithm uses patience diff. Special thanks to:
<a href="https://blog.jcoglan.com/2017/09/19/the-patience-diff-algorithm">https://blog.jcoglan.com/2017/09/19/the-patience-diff-algorithm</a>
<p>
The basic algorithm on before/after line lists: <ul>
  <li>skip unchanged lines on both top and bottom</li>
  <li>find unique lines in both sets and "align" them with
  using "longest increasing sequence"</li>
  <li>repeat for each aligned section</li>
</ul>
<p>
Example: <span class=code>io.fmt(Diff(linesA, linesB))</span>
<p>
<h1><a id=""Ty<lines.Writer>"" href="#"Ty<lines.Writer>"">Record lines.Writer</h1></a>
<p>
<h1><a id=""Ty<Gap>"" href="#"Ty<Gap>"">Record Gap</h1></a>
<ul>
  <li><b>bot</b> </li>
  <li><b>top</b> </li>
  <li><b>path</b> </li>
  <li><b>readonly</b> </li>
</ul>
<p>
<h1><a id=""Ty<lines.U3File>"" href="#"Ty<lines.U3File>"">Record lines.U3File</h1></a>
<ul>
  <li><b>f</b> </li>
  <li><b>path</b> </li>
  <li><b>mode</b> </li>
  <li><b>len</b> </li>
  <li><b>sz</b> :
  the size of each value</li>
</ul>
<p>
<h1><a id=""Ty<File>"" href="#"Ty<File>"">Record File</h1></a>
<ul>
  <li><b>path</b> </li>
  <li><b>mode</b> </li>
  <li><b>f</b> :
  open file</li>
  <li><b>idx</b> :
  line index of f</li>
  <li><b>cache</b> :
  cache of lines</li>
  <li><b>loadIdxFn</b> :
  default=lines.futils.loadIdx</li>
</ul>
<p>
<h1><a id=""Ty<EdFile>"" href="#"Ty<EdFile>"">Record EdFile</h1></a>
<ul>
  <li><b>lf</b> :
  indexed file</li>
  <li><b>dats</b> :
  list of Slc | Gap</li>
  <li><b>lens</b> :
  rolling sum of dat lengths</li>
</ul>
<p>
<h1><a id=""lines.futils"" href="#"lines.futils"">Mod lines.futils</h1></a>
utilities for file loading of lines.
<p>
<b>Functions</b> <ul>
  <li><span class=code>forceLoadIdx(f, idxpath)</span>
  Can be usd instead of loadIdx to force a reload of the index,
  ignoring modification times/etc.
  
  This is useful in some situtations where stat is not available.</li>
  <li><span class=code>loadIdx(f, idxpath, fmode, reindex) -&gt; idxFile</span>
  load or reindex the file at path to/from idxpath.</li>
</ul>
<p>
<h1><a id=""rebuf.motion"" href="#"rebuf.motion"">Mod rebuf.motion</h1></a>
module with helper methods for moving a cursor
around a lines-like 2D grid.
<p>
<b>Functions</b> <ul>
  <li><span class=code>decDistance(s, e) -&gt; int</span>
  decrease distance (start -> end) by 1</li>
  <li><span class=code>lcLe(l, c, l2, c2) -&gt; bool</span>
  return whether l.c is <= l2.c2</li>
  <li><span class=code>lcGe(l, c, l2, c2) -&gt; bool</span>
  return whether l.c is >= l2.c2</li>
  <li><span class=code>topLeft(l, c, l2, c2) -&gt; (l, c)</span>
  return the top-left of two points</li>
  <li><span class=code>lcWithin(l, c, l1, c1, l2, c2) -&gt; bool</span></li>
  <li><span class=code>wordKind(ch) -&gt; ws|sym|let</span></li>
  <li><span class=code>pathKind(ch) -&gt; ws|sym|path</span></li>
  <li><span class=code>forword(s, begin, getKind) -&gt; int</span>
  Go forward to find the start of the next word</li>
  <li><span class=code>backword(s, end_, getKind) -&gt; int</span>
  Go backward to find the start of this (or previous) word</li>
  <li><span class=code>getRange(s, i, getKind) -&gt; si,ei</span>
  get the <span class=code>range[si,ei]</span> of whatever is at <span class=code>s[i]</span>.</li>
  <li><span class=code>findBack(s, pat, end_, plain) -&gt; int</span>
  find backwards
  this searches for the pattern and returns the LAST one found.
  This is HORRIBLY non-performant, only use for small amounts of data</li>
</ul>
<p>
<b>table</b>: raw <span class=code>table</span>
<p>
<h1><a id=""lines.kev"" href="#"lines.kev"">Mod lines.kev</h1></a>
kev: "Key Equal Value" serialization format.
<p>
This is an extremely common format in many unix utilities, "good enough"
for a large number of configuration use cases. The format is simple: a file
containing lines of <span class=code>key=value</span>. The input and output are a table of
key,val strings (though tostring is called for <span class=code>to()</span>). Lines which don't
have <span class=code>=</span> in them are ignored.
<p>
Nested data is absolutely not supported. Spaces are treated as literal both
before and after <span class=code>=</span>. If you want a key containing <span class=code>=</span> or key/value
containing newline then use a different format.
<p>
<b>Functions</b> <ul>
  <li><span class=code>to(t)</span>
  convert to a table of <span class=code>key=value</span> lines.</li>
  <li><span class=code>from(lines, to)</span>
  convert <span class=code>key=value</span> lines to a table.</li>
  <li><span class=code>load(f, to) -&gt; M.from(lines.load(f), to)</span></li>
  <li><span class=code>dump(t, f) -&gt; lines.dump(M.to(t), f)</span></li>
</ul>
<p>
</div></body>
</html>
