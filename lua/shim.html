<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
write scripts for Lua, execute from shell. This is a tiny Lua module that makes
it easy to write utilities that work from either bash or Lua.
<p>
Example script (see also: <a href="#pkg-script">#pkg-script</a>) <div class=code-block>#!/usr/bin/env -S lua -e "require'pkglib'()"<br>
local G = G or _G -- typosafe globals<br>
<br>
--- module documentation<br>
local M = G.mod and mod'myCmdName' or {} -- self-documenting module<br>
G.MAIN = G.MAIN or M<br>
<br>
local mty = require'metaty'<br>
local shim = require'shim'<br>
<br>
--- Comamnd documentation<br>
M.Args = mty'Args' {<br>
&nbsp; 'name [string]: the name to say hello to', name='World',<br>
}<br>
<br>
M.main = function(args)<br>
&nbsp; args = M.Args(shim.parseStr(args))<br>
&nbsp; print('Hello '..args.name..'!')<br>
end<br>
<br>
if M == MAIN then os.exit(M.main(G.arg)) end<br>
return M -- return as library
</div>
<p>
Then in <span class=code>PKG.lua</span> add <span class=code>main = 'myCmdName.Main'</span> to enable better
documentation formatting. Get documentation with <span class=code>doc 'myCmdName'</span>.
<p>
<h1><a id=""shim"" href="#"shim"">Mod shim</h1></a>
shim: use a lua module in lua OR in the shell.
<p>
<b>Functions</b> <ul>
  <li><span class=code>parse(v) -&gt; args</span>
  Parse either a string or list and convert them to key=value table.
  v can be either a list of <span class=code>{'strings', '--option=foo'}</span>
  or <span class=code>{'strings", option='foo'}</span> or a combination of both. If v is a string then
  it is split on whitespace and parsed as a list.
  
  Note: this handles repeat keys by creating and appending a list for that key.</li>
  <li><span class=code>parseStr(str) -&gt; args</span>
  parses the string by splitting via whitespace.
  Asserts the string contains no special chars: <span class=code>'"[]</span>
  This is for convinience, use a table if it's not enough.
  
  Note: if the input is already a table it just returns it.</li>
  <li><span class=code>parseList(strlist) -&gt; args</span>
  Note: typically use parse() or parseStr() instead.</li>
  <li><span class=code>short(args, short, long, value) -&gt; nil</span>
  Helper for dealing with <span class=code>-s --short</span> arguments. Mutates
  args to convert short paramaters to their long counterpart.</li>
  <li><span class=code>boolean(v)</span>
  Duck type: always return a boolean (except for nil).
  See BOOLS (above) for mapping.</li>
  <li><span class=code>boolean(v)</span>
  Duck type: always return a boolean (except for nil).
  See BOOLS (above) for mapping.</li>
  <li><span class=code>bools(args, ...)</span></li>
  <li><span class=code>number(num)</span>
  Duck type: always return a number</li>
  <li><span class=code>string(v)</span>
  Duck type: always return a string
  This is useful for some APIs where you want to convert
  number/true/false to strings
  Converts nil to ''</li>
  <li><span class=code>list(val, default, empty)</span></li>
  <li><span class=code>listSplit(val, sep)</span>
  Duck type: if val is a string then splits it
  if it's a list leaves alone.</li>
  <li><span class=code>file(v, default, mode--[[w+]]) -&gt; file, error?</span>
  Duck type: get a file handle.
  If <span class=code>v or default</span> is a string then open the file in mode <span class=code>default='w+'</span></li>
  <li><span class=code>expand(args)</span>
  expand string keys into <span class=code>--key=value</span>, ordered alphabetically.
  This is mostly useful for interfacing with non-lua shells.</li>
  <li><span class=code>getEnvBool(k)</span></li>
  <li><span class=code>popRaw(args, to) -&gt; to</span>
  pop raw arguments after '--'
  Removes them (including '--') from args.</li>
  <li><span class=code>runSetup(args, force)</span>
  Setup lua using <span class=code>require(LUA_SETUP).setup(args, force)</span>.
  
  The default is to use ds.setup.</li>
  <li><span class=code>construct(Args, args) -&gt; ok, err?</span>
  Construct a metaty-like object from args.
  
  If <span class=code>Args.subcmd</span> is truthy then treats it as a table of
  subcmds. Looks for a subcmd at <span class=code>args[1]</span>, removes it and
  constructs that subcmd, returning a table with the subcmd
  key set.
  
  For example:
  <span class=code>construct({foo=Foo, bar=Bar}, {'foo', 'ding', zing=true})</span>
  returns a {foo=Foo{'ding', zing=true}}.</li>
  <li><span class=code>init(Args, args)</span>
  Convienience function to perform common setup and run a command-like object.</li>
  <li><span class=code>run(Args, args)</span></li>
</ul>
<p>
</div></body>
</html>
