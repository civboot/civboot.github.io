<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1>shim: command line library for lua.</h1>
Write scripts as Lua libraries, execute them in the shell.

<p>
<p>This is a tiny Lua module that makes it easy to write utilities
that work from either bash or Lua.

<p><b>Usage:</b> <div class=code-block>#!/usr/bin/env -S lua -e "require'pkglib'()"<br>
local shim = require'shim'<br>
<br>
local M = shim.cmd'myModName' {<br>
&nbsp; 'arg [type]: documentation',<br>
&nbsp; &nbsp; arg = 'default-value',<br>
}<br>
<br>
-- ... nomral lua module<br>
function M.someFunction() ... end<br>
<br>
if shim.isMain(M) then M:main(arg) end<br>
return M -- return as library
</div>

<p><h3><a id="shim" href="#shim" class=anchor>Mod shim</h3></a>
shim: command line library for lua.

<p><b>Functions</b> <ul>
  <li><a id="shim.parse" href="#shim.parse" class=anchor><b>fn parse</b></a><span class=code>(v) -&gt; args</span><br>
  
  Parse either a string or list and convert them to key=value table.
  v can be either a list of <span class=code>{'strings', '--option=foo'}</span>
  or <span class=code>{'strings", option='foo'}</span> or a combination of both. If v is a string then
  it is split on whitespace and parsed as a list.
  
  <p>Note: this handles repeat keys by creating and appending a list for that key.</li>
  <li><a id="shim.parseStr" href="#shim.parseStr" class=anchor><b>fn parseStr</b></a><span class=code>(str) -&gt; args</span><br>
  
  parses the string by splitting via whitespace.
  Asserts the string contains no special chars: <span class=code>'"[]</span>
  This is for convinience, use a table if it's not enough.
  
  <p>Note: if the input is already a table it just returns it.</li>
  <li><a id="shim.parseList" href="#shim.parseList" class=anchor><b>fn parseList</b></a><span class=code>(strlist) -&gt; args</span><br>
  
  Note: typically use parse() or parseStr() instead.</li>
  <li><a id="shim.short" href="#shim.short" class=anchor><b>fn short</b></a><span class=code>(args, short, long, value) -&gt; nil</span><br>
  
  Helper for dealing with <span class=code>-s --short</span> arguments. Mutates
  args to convert short paramaters to their long counterpart.</li>
  <li><a id="shim.boolean" href="#shim.boolean" class=anchor><b>fn boolean</b></a><span class=code>(v)</span><br>
  
  Duck type: always return a boolean (except for nil).
  See BOOLS (above) for mapping.</li>
  <li><a id="shim.boolean" href="#shim.boolean" class=anchor><b>fn boolean</b></a><span class=code>(v)</span><br>
  
  Duck type: always return a boolean (except for nil).
  See BOOLS (above) for mapping.</li>
  <li><a id="shim.bools" href="#shim.bools" class=anchor><b>fn bools</b></a><span class=code>(args, ...)</span></li>
  <li><a id="shim.number" href="#shim.number" class=anchor><b>fn number</b></a><span class=code>(num)</span><br>
  
  Duck type: always return a number</li>
  <li><a id="shim.string" href="#shim.string" class=anchor><b>fn string</b></a><span class=code>(v)</span><br>
  
  Duck type: always return a string
  This is useful for some APIs where you want to convert
  number/true/false to strings
  <div class=info>Converts nil to ''</div></li>
  <li><a id="shim.list" href="#shim.list" class=anchor><b>fn list</b></a><span class=code>(val, default, empty)</span><br>
  
  Duck type: always return a list.<ul>
    <li>default controls val==nil</li>
    <li>empty   controls val==''</li>
  </ul></li>
  <li><a id="shim.listSplit" href="#shim.listSplit" class=anchor><b>fn listSplit</b></a><span class=code>(val, sep)</span><br>
  
  Duck type: if val is a string then splits it
  if it's a list leaves alone.</li>
  <li><a id="shim.file" href="#shim.file" class=anchor><b>fn file</b></a><span class=code>(v, default, mode--[[w+]]) -&gt; file, error?</span><br>
  
  Duck type: get a file handle.
  If <span class=code>v or default</span> is a string then open the file in mode <span class=code>default='w+'</span></li>
  <li><a id="shim.expand" href="#shim.expand" class=anchor><b>fn expand</b></a><span class=code>(args)</span><br>
  
  expand string keys into <span class=code>--key=value</span>, ordered alphabetically.
  This is mostly useful for interfacing with non-lua shells.</li>
  <li><a id="shim.getEnvBool" href="#shim.getEnvBool" class=anchor><b>fn getEnvBool</b></a><span class=code>(k)</span><br>
  
  return nil if env var does not exist, else boolean (true for 'true' or '1')</li>
  <li><a id="shim.popRaw" href="#shim.popRaw" class=anchor><b>fn popRaw</b></a><span class=code>(args, to) -&gt; to</span><br>
  
  pop raw arguments after '--'
  Removes them (including '--') from args.</li>
  <li><a id="shim.runSetup" href="#shim.runSetup" class=anchor><b>fn runSetup</b></a><span class=code>(args, force)</span><br>
  
  Setup lua using <span class=code>require(LUA_SETUP).setup(args, force)</span>.
  
  <p>The default is to use ds.setup.</li>
  <li><a id="shim.construct" href="#shim.construct" class=anchor><b>fn construct</b></a><span class=code>(Cmd, args) -&gt; ok, err?</span></li>
  <li><a id="shim.constructNew" href="#shim.constructNew" class=anchor><b>fn constructNew</b></a><span class=code>(Cmd, args) -&gt; ok, err?</span></li>
  <li><a id="shim.init" href="#shim.init" class=anchor><b>fn init</b></a><span class=code>(Cmd, args)</span><br>
  
  FIXME delete</li>
  <li><a id="shim.run" href="#shim.run" class=anchor><b>fn run</b></a><span class=code>(Args, args)</span></li>
  <li><a id="shim.isCmd" href="#shim.isCmd" class=anchor><b>fn isCmd</b></a><span class=code>(R)</span><br>
  
  Return whether a record was created with <b>fn cmd</b></li>
  <li><a id="shim.cmd" href="#shim.cmd" class=anchor><b>fn cmd</b></a><span class=code>(name)</span><br>
  
  Create a new command as your module.
  
  <p><div class=code-block>local M = shim.cmd'mycmd' {<br>
&nbsp; '...: argument documentation',<br>
&nbsp; 'foo: some paramater',<br>
&nbsp; 'to [path|file]: where to write output',<br>
}<br>
-- ... rest of your module.<br>
if shim.isMain(M) then M:main(arg) end<br>
return M
</div></li>
  <li><a id="shim.subcmds" href="#shim.subcmds" class=anchor><b>fn subcmds</b></a><span class=code>(name)</span><br>
  
  Create a command composed of subcommands.</li>
  <li><a id="shim.isMain" href="#shim.isMain" class=anchor><b>fn isMain</b></a><span class=code>(cmd)</span><br>
  
  Usage: <span class=code>if shim.isMain(M) then os.exit(M:main(arg)) end</span></li>
</ul>

<p>
</div></body>
</html>
