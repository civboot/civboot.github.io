<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
JSON+ de/serializer in pure lua
<p>
This folder defines an LSON spec and an example public domain pure-lua
implementation of LSON/JSON encoder and decoder.
<p>
<h3>Lua Library</h3>
lson is a pure-lua JSON+ de/serialization library. The main functions are
the encoding functions <span class=code>json()</span> and <span class=code>lson()</span> and the  <span class=code>decode()</span> function
(which decodes either encoder's output).
<p>
See also the types <a href="#lson.Json">#lson.Json</a>, <a href="#lson.Lson">#lson.Lson</a> and <a href="#lson.Decoder">#lson.Decoder</a> and
their documentation to have more control of the usage, including pretty printing
and a decoding iterator.
<p>
<div class=info>Note: If you want highly performant or compliant JSON library then use a
different one. This library is part of the civlua project and is optimized for
simplicy and improved features.</div>
<p>
<h3><a id="lson-spec" href="#lson-spec">LSON spec</h3></a>
LSON is a strict superset of JSON: all valid JSON is valid LSON but not vice
versa. The difference is: <ul>
  <li>LSON ignores commas (it treats them as whitespace). List and map entries can
  be separated by any whitespace (including commas). This makes it easier for
  a human to write and vcs to diff.</li>
  <li>LSON adds binary syntax for bytes <span class=code>|any binary data|</span>. The data within</li>
  <li><span class=code>|...|</span> is arbitrary bytes except the following will be converted:
  <span class=code>\\ -&gt; \ &nbsp; \| -&gt; | &nbsp; &nbsp;\n -&gt; newline</span>
  Other "escapes" are preserved, i.e. <span class=code>\d -&gt; \d</span>. This makes encoding binary
  data in LSON MUCH more compact (and possible) than JSON.</li>
</ul>
<p>
<h1><a id=""lson"" href="#"lson"">Mod lson</h1></a>
<p>
<b>Types</b> <ul>
  <li><b>lson.Json</b></li>
  <li><b>lson.Lson</b></li>
  <li><b>lson.De</b></li>
</ul>
<p>
<b>Functions</b> <ul>
  <li><span class=code>json(v, pretty) -&gt; string</span>
  Encode lua value to JSON string</li>
  <li><span class=code>lson(v, pretty) -&gt; string</span>
  Encode lua value to LSON string</li>
  <li><span class=code>decode(s, podder, pset) -&gt; obj</span></li>
  <li><span class=code>bytes(f, s)</span></li>
  <li><span class=code>deNull(de) -&gt; de.null</span></li>
  <li><span class=code>deTrue(de) -&gt; true</span></li>
  <li><span class=code>deFalse(de) -&gt; false</span></li>
  <li><span class=code>deNumber(de)</span></li>
  <li><span class=code>deString(de)</span></li>
  <li><span class=code>deBytes(de)</span></li>
  <li><span class=code>deArray(de)</span></li>
  <li><span class=code>deObject(de)</span></li>
</ul>
<p>
<h2><a id=""lson.Json"" href="#"lson.Json"">Record Json</h2></a>
<ul>
  <li><b>style</b> :
  enable styling. If true, set <span class=code>to=Styler</span></li>
  <li><b>to</b> :
  if set calls write</li>
  <li><b>keyEnd</b> </li>
  <li><b>keySet</b> </li>
  <li><b>indexEnd</b> </li>
  <li><b>tableStart</b> </li>
  <li><b>tableEnd</b> </li>
  <li><b>listEnd</b> </li>
  <li><b>indent</b> </li>
  <li><b>maxIndent</b> </li>
  <li><b>numfmt</b> </li>
  <li><b>strfmt</b> </li>
  <li><b>table</b> </li>
  <li><b>string</b> </li>
  <li><b>null</b> :
  value to use for null</li>
  <li><b>listStart</b> </li>
  <li><b>listEnd</b> </li>
</ul>
Json Encoder (via fmt.Fmt)
This works identically to metaty.Fmt except it overrides
how tables are formatted to use JSON instead of printing them.
<p>
<h2><a id=""lson.Lson"" href="#"lson.Lson"">Record Lson</h2></a>
<ul>
  <li><b>style</b> :
  enable styling. If true, set <span class=code>to=Styler</span></li>
  <li><b>to</b> :
  if set calls write</li>
  <li><b>keyEnd</b> </li>
  <li><b>keySet</b> </li>
  <li><b>indexEnd</b> </li>
  <li><b>tableStart</b> </li>
  <li><b>tableEnd</b> </li>
  <li><b>listEnd</b> </li>
  <li><b>indent</b> </li>
  <li><b>maxIndent</b> </li>
  <li><b>numfmt</b> </li>
  <li><b>strfmt</b> </li>
  <li><b>table</b> </li>
  <li><b>string</b> </li>
  <li><b>null</b> :
  value to use for null</li>
  <li><b>listStart</b> </li>
  <li><b>listEnd</b> </li>
</ul>
Similar to JSON but no commas and strings are encoded as <span class=code>|bytes|</span>
<p>
<h2><a id=""lson.De"" href="#"lson.De"">Record De</h2></a>
<ul>
  <li><b>dat</b> :
  lines-like data to parse</li>
  <li><b>null</b> :
  value to use for null</li>
  <li><b>l</b> </li>
  <li><b>c</b> </li>
  <li><b>line</b> </li>
</ul>
<span class=code>De(string or lines) -&gt; value-iter</span>
<span class=code>for val in De'["my", "lson"]' do ... end</span>
<p>
</div></body>
</html>
