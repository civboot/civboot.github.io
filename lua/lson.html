<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1>JSON+ de/serializer in pure lua</h1>
<br>
This folder defines an LSON spec and an example public domain pure-lua
implementation of LSON/JSON encoder and decoder.
<br>
<div class=info>Note: If you want highly performant or compliant JSON library then use a
different one. This library is part of the civstack project and is optimized for
simplicy and improved features.</div>
<br>
<h3><a id="lson-spec" href="#lson-spec" class=anchor>LSON spec</h3></a>
LSON is a strict superset of JSON: all valid JSON is valid LSON but not vice
versa. The difference is: <ul>
  <li>LSON ignores commas (it treats them as whitespace). List and map entries can
  be separated by any whitespace (including commas). This makes it easier for
  a human to write and vcs to diff.</li>
  <li>LSON adds binary syntax for bytes <span class=code>|any binary data|</span>. The data within
  <span class=code>|...|</span> is arbitrary bytes except the following will be converted:
  <span class=code>\\ -&gt; \ &nbsp; \| -&gt; | &nbsp; &nbsp;\n -&gt; newline</span>
  Other "escapes" are preserved, i.e. <span class=code>\d -&gt; \d</span>. This makes encoding binary
  data in LSON MUCH more compact (and possible) than JSON.</li>
</ul>
<br>
<h4><a id="lson" href="#lson" class=anchor>Command lson</h4></a>
lson JSON+ command and library.
<br>
<b>Cmd usage:</b> <span class=code>lson path/to/file.json</span><br>

The command pretty-prints JSON+ as a lua object.
<br>
<br>
<b>Lib usage:</b> <span class=code>tbl = lson.decode('{1: 2}')</span><br>

As a library it allows de/serialization of JSON+ to/from
Lua values.
<br>
<b>Types: </b><a href="#lson.Json">Json</a> <a href="#lson.Lson">Lson</a> <a href="#lson.De">De</a> 
<br>
<b>Methods and Functions</b> <ul>
  <li><a id="lson.json" href="#lson.json" class=anchor><b>fn json</b></a><span class=code>(v, pretty) -&gt; string</span><br>
  
  Encode lua value to JSON string</li>
  <li><a id="lson.lson" href="#lson.lson" class=anchor><b>fn lson</b></a><span class=code>(v, pretty) -&gt; string</span><br>
  
  Encode lua value to LSON string</li>
  <li><a id="lson.decode" href="#lson.decode" class=anchor><b>fn decode</b></a><span class=code>(s, podder, pset) -&gt; value</span><br>
  
  Decode JSON/LSON string or lines object to a lua value.</li>
  <li><a id="lson.bytes" href="#lson.bytes" class=anchor><b>fn bytes</b></a><span class=code>(f, s)</span><br>
  
  The bytes type-encoder. Encodes as <span class=code>|bytes|</span> instead of <span class=code>"string"</span> for
  lson You can set <span class=code>Enc.string = lson.bytes</span> for this behavior (or use the
  Lson type).</li>
</ul>
<br>
<h4><a id="lson.Json" href="#lson.Json" class=anchor>Record Json</h4></a>
Json Encoder (via fmt.Fmt)
This works identically to metaty.Fmt except it overrides
how tables are formatted to use JSON instead of printing them.
<br>
<b>Fields:</b><ul>
  <li><a id="lson.Json.style" href="#lson.Json.style" class=anchor><b>style</b></a>
  enable styling. If true, set <span class=code>to=Styler</span></li>
  <li><a id="lson.Json.to" href="#lson.Json.to" class=anchor><b>to</b></a>
  if set calls write</li>
  <li><a id="lson.Json.keyEnd" href="#lson.Json.keyEnd" class=anchor><b>keyEnd</b></a> <span class=code>=","</span></li>
  <li><a id="lson.Json.keySet" href="#lson.Json.keySet" class=anchor><b>keySet</b></a> <span class=code>=":"</span></li>
  <li><a id="lson.Json.indexEnd" href="#lson.Json.indexEnd" class=anchor><b>indexEnd</b></a> <span class=code>=","</span></li>
  <li><a id="lson.Json.tableStart" href="#lson.Json.tableStart" class=anchor><b>tableStart</b></a> <span class=code>="{"</span></li>
  <li><a id="lson.Json.tableEnd" href="#lson.Json.tableEnd" class=anchor><b>tableEnd</b></a> <span class=code>="}"</span></li>
  <li><a id="lson.Json.listEnd" href="#lson.Json.listEnd" class=anchor><b>listEnd</b></a> <span class=code>="]"</span></li>
  <li><a id="lson.Json.indent" href="#lson.Json.indent" class=anchor><b>indent</b></a> <span class=code>=" &nbsp;"</span></li>
  <li><a id="lson.Json.maxIndent" href="#lson.Json.maxIndent" class=anchor><b>maxIndent</b></a> <span class=code>=20</span></li>
  <li><a id="lson.Json.numfmt" href="#lson.Json.numfmt" class=anchor><b>numfmt</b></a> <span class=code>="%q"</span></li>
  <li><a id="lson.Json.strfmt" href="#lson.Json.strfmt" class=anchor><b>strfmt</b></a> <span class=code>="%q"</span></li>
  <li><a id="lson.Json.table" href="#lson.Json.table" class=anchor><b>table</b></a> <span class=code>=function() instance</span></li>
  <li><a id="lson.Json.string" href="#lson.Json.string" class=anchor><b>string</b></a> <span class=code>=function() instance</span></li>
  <li><a id="lson.Json.null" href="#lson.Json.null" class=anchor><b>null</b></a> <span class=code>=ds.none</span>
  value to use for null</li>
  <li><a id="lson.Json.listStart" href="#lson.Json.listStart" class=anchor><b>listStart</b></a> <span class=code>="["</span></li>
  <li><a id="lson.Json.listEnd" href="#lson.Json.listEnd" class=anchor><b>listEnd</b></a> <span class=code>="]"</span></li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Json.toPretty" href="#Json.toPretty" class=anchor><b>fn:toPretty</b></a><span class=code>()</span></li>
  <li><a id="Json.pretty" href="#Json.pretty" class=anchor><b>fn pretty</b></a><span class=code>(E, t)</span></li>
  <li><a id="Json.level" href="#Json.level" class=anchor><b>fn:level</b></a><span class=code>(add) -&gt; int: current level</span><br>
  
  Add to the indent level and get the new value
  call with <span class=code>add=nil</span> to just get the current level</li>
  <li><a id="Json.write" href="#Json.write" class=anchor><b>fn:write</b></a><span class=code>(...)</span><br>
  
  Same as <span class=code>file:write</span>.</li>
  <li><a id="Json.flush" href="#Json.flush" class=anchor><b>fn:flush</b></a><span class=code>()</span></li>
  <li><a id="Json.close" href="#Json.close" class=anchor><b>fn:close</b></a><span class=code>()</span></li>
  <li><a id="Json.styled" href="#Json.styled" class=anchor><b>fn:styled</b></a><span class=code>(style, text, ...)</span><br>
  
  Call <span class=code>to:styled(...)</span> if it is enabled, else simply <span class=code>self:write(text, ...)</span>.
  This allows for configurable styling of output, both for objects as well
  as command-line utilities/etc.</li>
  <li><a id="Json.tableKey" href="#Json.tableKey" class=anchor><b>fn tableKey</b></a><span class=code>(f, v, podder, pod)</span></li>
  <li><a id="Json.nil" href="#Json.nil" class=anchor><b>fn nil</b></a><span class=code>(self)</span><br>
  
  format a nil value.</li>
  <li><a id="Json.boolean" href="#Json.boolean" class=anchor><b>fn:boolean</b></a><span class=code>(b)</span><br>
  
  format a boolean value.</li>
  <li><a id="Json.number" href="#Json.number" class=anchor><b>fn:number</b></a><span class=code>(n)</span><br>
  
  format a number value.</li>
  <li><a id="Json.string" href="#Json.string" class=anchor><b>fn string</b></a><span class=code>(enc, s)</span></li>
  <li><a id="Json.thread" href="#Json.thread" class=anchor><b>fn:thread</b></a><span class=code>(th)</span><br>
  
  format a thread value.</li>
  <li><a id="Json.userdata" href="#Json.userdata" class=anchor><b>fn:userdata</b></a><span class=code>(ud)</span><br>
  
  format a userdata value.</li>
  <li><a id="Json.function" href="#Json.function" class=anchor><b>fn function</b></a><span class=code>(self, fn)</span><br>
  
  format a function value.</li>
  <li><a id="Json.items" href="#Json.items" class=anchor><b>fn:items</b></a><span class=code>(t, hasKeys, listEnd)</span><br>
  
  format items in table "list"</li>
  <li><a id="Json.keyvals" href="#Json.keyvals" class=anchor><b>fn:keyvals</b></a><span class=code>(t, keys)</span><br>
  
  format key/vals in table "map".</li>
  <li><a id="Json.list" href="#Json.list" class=anchor><b>fn:list</b></a><span class=code>(t)</span><br>
  
  Format only the list-elements of a table.</li>
  <li><a id="Json.rawtable" href="#Json.rawtable" class=anchor><b>fn:rawtable</b></a><span class=code>(t)</span></li>
  <li><a id="Json.table" href="#Json.table" class=anchor><b>fn table</b></a><span class=code>(f, t)</span></li>
  <li><a id="Json.format" href="#Json.format" class=anchor><b>fn:format</b></a><span class=code>(fmt, ...) -&gt; varargsUsed</span><br>
  
  like string.format but use <span class=code>Fmt</span> for <span class=code>%q</span>.
  Doesn't return the string, instead writes to <span class=code>Fmt</span></li>
  <li><a id="Json.concat" href="#Json.concat" class=anchor><b>fn:concat</b></a><span class=code>(sep, ...) -&gt; self</span><br>
  
  fmt ... separated by sep</li>
  <li><a id="Json.tabulated" href="#Json.tabulated" class=anchor><b>fn:tabulated</b></a><span class=code>('\t', ...)</span><br>
  
  fmt ... separated by tabs</li>
  <li><a id="Json.lined" href="#Json.lined" class=anchor><b>fn:lined</b></a><span class=code>('\n', ...)</span><br>
  
  fmt ... separated by newlines</li>
  <li><a id="Json.tostring" href="#Json.tostring" class=anchor><b>fn:tostring</b></a><span class=code>()</span><br>
  
  Returns the concattenated string written to the
  formatter.<br>
  
  Error if <span class=code>to</span> is set.</li>
</ul>
<br>
<h4><a id="lson.Lson" href="#lson.Lson" class=anchor>Record Lson</h4></a>
Similar to JSON but no commas and strings are encoded as <span class=code>|bytes|</span>
<br>
<b>Fields:</b><ul>
  <li><a id="lson.Lson.style" href="#lson.Lson.style" class=anchor><b>style</b></a>
  enable styling. If true, set <span class=code>to=Styler</span></li>
  <li><a id="lson.Lson.to" href="#lson.Lson.to" class=anchor><b>to</b></a>
  if set calls write</li>
  <li><a id="lson.Lson.keyEnd" href="#lson.Lson.keyEnd" class=anchor><b>keyEnd</b></a> <span class=code>=" "</span></li>
  <li><a id="lson.Lson.keySet" href="#lson.Lson.keySet" class=anchor><b>keySet</b></a> <span class=code>=":"</span></li>
  <li><a id="lson.Lson.indexEnd" href="#lson.Lson.indexEnd" class=anchor><b>indexEnd</b></a> <span class=code>=" "</span></li>
  <li><a id="lson.Lson.tableStart" href="#lson.Lson.tableStart" class=anchor><b>tableStart</b></a> <span class=code>="{"</span></li>
  <li><a id="lson.Lson.tableEnd" href="#lson.Lson.tableEnd" class=anchor><b>tableEnd</b></a> <span class=code>="}"</span></li>
  <li><a id="lson.Lson.listEnd" href="#lson.Lson.listEnd" class=anchor><b>listEnd</b></a> <span class=code>="]"</span></li>
  <li><a id="lson.Lson.indent" href="#lson.Lson.indent" class=anchor><b>indent</b></a> <span class=code>=" &nbsp;"</span></li>
  <li><a id="lson.Lson.maxIndent" href="#lson.Lson.maxIndent" class=anchor><b>maxIndent</b></a> <span class=code>=20</span></li>
  <li><a id="lson.Lson.numfmt" href="#lson.Lson.numfmt" class=anchor><b>numfmt</b></a> <span class=code>="%q"</span></li>
  <li><a id="lson.Lson.strfmt" href="#lson.Lson.strfmt" class=anchor><b>strfmt</b></a> <span class=code>="%q"</span></li>
  <li><a id="lson.Lson.table" href="#lson.Lson.table" class=anchor><b>table</b></a> <span class=code>=function() instance</span></li>
  <li><a id="lson.Lson.string" href="#lson.Lson.string" class=anchor><b>string</b></a> <span class=code>=lson.bytes</span></li>
  <li><a id="lson.Lson.null" href="#lson.Lson.null" class=anchor><b>null</b></a> <span class=code>=ds.none</span>
  value to use for null</li>
  <li><a id="lson.Lson.listStart" href="#lson.Lson.listStart" class=anchor><b>listStart</b></a> <span class=code>="["</span></li>
  <li><a id="lson.Lson.listEnd" href="#lson.Lson.listEnd" class=anchor><b>listEnd</b></a> <span class=code>="]"</span></li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Lson.pretty" href="#Lson.pretty" class=anchor><b>fn pretty</b></a><span class=code>(E, t)</span></li>
  <li><a id="Lson.string" href="#Lson.string" class=anchor><b>fn string</b></a><span class=code>(f, s)</span><br>
  
  The bytes type-encoder. Encodes as <span class=code>|bytes|</span> instead of <span class=code>"string"</span> for
  lson You can set <span class=code>Enc.string = lson.bytes</span> for this behavior (or use the
  Lson type).</li>
</ul>
<br>
<h4><a id="lson.De" href="#lson.De" class=anchor>Record De</h4></a>
<span class=code>De(string or lines) -&gt; value-iter</span>
<span class=code>for val in De'["my", "lson"]' do ... end</span>
<br>
<b>Fields:</b><ul>
  <li><a id="lson.De.dat" href="#lson.De.dat" class=anchor><b>dat</b></a>
  lines-like data to parse</li>
  <li><a id="lson.De.null" href="#lson.De.null" class=anchor><b>null</b></a> <span class=code>=ds.none</span>
  value to use for null</li>
  <li><a id="lson.De.l" href="#lson.De.l" class=anchor><b>l</b></a></li>
  <li><a id="lson.De.c" href="#lson.De.c" class=anchor><b>c</b></a></li>
  <li><a id="lson.De.line" href="#lson.De.line" class=anchor><b>line</b></a></li>
</ul>
<b>Methods</b> <ul>
  <li><a id="De.assert" href="#De.assert" class=anchor><b>fn assert</b></a><span class=code>(de, ok, msg)</span></li>
  <li><a id="De.skipWs" href="#De.skipWs" class=anchor><b>fn skipWs</b></a><span class=code>(de, eofOkay)</span></li>
  <li><a id="De.consume" href="#De.consume" class=anchor><b>fn consume</b></a><span class=code>(de, pat, context)</span></li>
</ul>
<br>
</div></body>
</html>
