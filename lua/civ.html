<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1><a id="civ_build_system_and_pkg_manager" href="#civ_build_system_and_pkg_manager" class=anchor>civ build system and pkg manager</h1></a>
Civstack is a full developer tech stack, and the bedrock of that is the build
system -- which is this command (<span class=code>civ</span>).
<br>
<br>
A "build system" is fundamentally a mechanism to convert a set of files and
configuration (a package) into runnable (and testable) software. A package
manager is then a way to depend on other packages.
<br>
<br>
A <i>good</i> build system has two other primary features: <ul>
  <li>ergonomics: package specification is complete and easy to both read and write.</li>
  <li>hermetic: each built component <i>can</i> be isolated from the rest of the system
  and deterministically built.</li>
</ul>
<br>
<h3><a id="PKG.luk" href="#PKG.luk" class=anchor>PKG.luk</h3></a>
The <span class=code>PKG.luk</span> file is is how you specify how to build a package and what is
exported from that package. Below is an example one which we will walk though.
Before we do, a few notes:
<ul>
  <li>This file is 100% pure lua except with different builtin globals, hence the
  different file extension (<span class=code>.luk</span>)</li>
  <li>Noteablly very few of lua's builtin functions or modules are available.
  Instead there are several functions for importing non-PKG luk files.</li>
</ul>
<br>
Example <span class=code>PKG.luk</span>:
<div class=code-block>local P = { summary = "Does foo and some bar" }<br>
<br>
--- Imports a function to help us create Target<br>
local cc &nbsp;= import'sys:cc.luk' &nbsp;-- C build targets<br>
local lua = import'sys:lua.luk' -- Lua build targets<br>
<br>
-- Set up metadata for this PKG.luk file, this must be<br>
-- returned at the end with the targets and PoD to provide<br>
-- clients.<br>
--<br>
-- This also creates the global `P` value, which is the data<br>
-- (build information) exported by this file.<br>
P.foo = lua {<br>
&nbsp; mod = 'foo',<br>
&nbsp; src = { 'foo.lua' },<br>
&nbsp; dep = {<br>
&nbsp; &nbsp; 'civ:lib', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- depend on entire civ lib<br>
&nbsp; &nbsp; 'myhub:foo#libfoo', &nbsp;-- depend on next target<br>
&nbsp; },<br>
}<br>
<br>
-- test rule<br>
P.test = lua.test {<br>
&nbsp; src = 'test.lua',<br>
&nbsp; dep = { 'myhub:foo' },<br>
}<br>
<br>
-- C build target<br>
P.libfoo = cc {<br>
&nbsp; hdr = { 'foo.h' }, &nbsp;-- C headers<br>
&nbsp; src = { 'foo.c' }, &nbsp;-- C source files<br>
&nbsp; dep = {<br>
&nbsp; &nbsp; 'myhub:bar#libbar', -- depend on another target<br>
&nbsp; },<br>
}<br>
<br>
return P
</div>
<br>
<div class=info>Every value assigned to <span class=code>P</span> must be either a concrete type or a
<a href="#civ.core.Target">#civ.core.Target</a>.
</div>
<br>
<h3><a id="civ-out" href="#civ-out" class=anchor>civ output directory</h3></a>
By default, <span class=code>civ build</span> puts files in <span class=code>.civ/</span>. Wherever it puts it's output
(whether during build or installation), the output structure under that directory
is as follows: <ul>
  <li><span class=code>bin/</span>: executables (and links to them) go here and must not conflict.</li>
  <li><span class=code>lua/</span>: contains all <span class=code>mod.lua</span> files, and the sub-module files under
  <span class=code>mod/sub.lua</span>. This conforms with
  <a href="https://www.lua.org/manual/5.4/manual.html#pdf-package.searchpath">package.searchpath</a>,
  which allows the normal lua loader to load these packages with <span class=code>LUA_PATH</span>
  set to <span class=code>.../civ/lua/?.lua</span>.</li>
  <li><span class=code>data/</span>: contains arbitrary data files defined by targets.</li>
  <li><span class=code>lib/</span>: all library files in a flat directory, all of which must start with
  <span class=code>lib</span> i.e. <span class=code>libfoo.so</span>. This is to conform with the envornment variables
  <span class=code>LUA_CPATH, LD_LIBRARY_PATH</span>, etc as well as the <span class=code>cc -l</span> flag.</li>
  <li><span class=code>include/</span>: header files, both <span class=code>.h</span> and <span class=code>.iH</span> (iA header) for linking
  dynamic libraries during compilation.</li>
  <li><span class=code>log/</span>: contains metadata about what each target installed, i.e. <span class=code>log/mypkg/foo.files</span> used
  by the build system for incremental builds as well as by installation system to remove
  files during uninstall.</li>
</ul>
<br>
<h3><a id="civ" href="#civ" class=anchor>Command civ</h3></a>
civ command
<h4><a id="init" href="#init" class=anchor>Subcmd init</h4></a>
Usage: <span class=code>civ init --config=.civconfig.lua</span><br>

Initialize the repository. This should be run when starting a new repo.
<b>Arguments:</b><ul>
  <li><a id="init.config" href="#init.config" class=anchor><b>config</b></a>
  path to config.lua to output</li>
  <li><a id="init.base" href="#init.base" class=anchor><b>base</b></a>
  base config to copy from</li>
</ul>
<h4><a id="build" href="#build" class=anchor>Subcmd build</h4></a>
Usage: <span class=code>civ build hub:tgt#name</span><br>

Build targets which match the pattern.
<b>Arguments:</b><ul>
  <li><a id="civ.build.config" href="#civ.build.config" class=anchor><b>config</b></a>
  path to civ config.</li>
</ul>
<h4><a id="test" href="#test" class=anchor>Subcmd test</h4></a>
Usage: <span class=code>civ test hub:tgt#name</span><br>

Test targets which match the pattern.
<b>Arguments:</b><ul>
  <li><a id="civ.test.config" href="#civ.test.config" class=anchor><b>config</b></a>
  path to civ config.</li>
</ul>
<h4><a id="run" href="#run" class=anchor>Subcmd run</h4></a>
Usage: <span class=code>civ run hub:tgt#name -- ...args</span><br>

Build+run a single build target which has a single bin or link output.
<b>Arguments:</b><ul>
  <li><a id="civ.run.config" href="#civ.run.config" class=anchor><b>config</b></a>
  path to civ config.</li>
</ul>
<h4><a id="install" href="#install" class=anchor>Subcmd install</h4></a>
Usage: <span class=code>civ install hub:tgt#name</span><br>

Install targets which match the pattern.
<b>Arguments:</b><ul>
  <li><a id="civ.install.config" href="#civ.install.config" class=anchor><b>config</b></a>
  path to civ config.</li>
  <li><a id="civ.install.force" href="#civ.install.force" class=anchor><b>force</b></a>
  do not confirm deletion of files.</li>
</ul>
<br>
<h3><a id="civ.core" href="#civ.core" class=anchor>Mod civ.core</h3></a>
<b>civ.core</b> contains types used by the civ build system.<br>

<br>
<br>
<br>
<div class=info>If you are just a user of civ this is likely not useful. This library is
<br>
useful primarily for those who want to extend civ and/or write their own
<br>
build/test macros.</div>
<br>
<br>
<b>Types: </b><a href="#civ.core.TargetName">TargetName</a> <a href="#civ.core.Target">Target</a> <a href="#civ.core.Hub">Hub</a> <a href="#civ.core.CfgBuilder">CfgBuilder</a> <a href="#civ.core.Cfg">Cfg</a> <a href="#civ.core.Civ">Civ</a> 
<br>
<b>Functions</b> <ul>
  <li><a id="civ.core.tgtnameSplit" href="#civ.core.tgtnameSplit" class=anchor><b>fn tgtnameSplit</b></a></li>
  <li><a id="civ.core.tgtname" href="#civ.core.tgtname" class=anchor><b>fn tgtname</b></a><span class=code>(tgtname)</span></li>
</ul>
<br>
<h4><a id="civ.core.TargetName" href="#civ.core.TargetName" class=anchor>Record TargetName</h4></a>
Represents a pkgname.target parsed from a string
<br>
<b>Fields:</b><ul>
  <li><a id="civ.core.TargetName.pkgname" href="#civ.core.TargetName.pkgname" class=anchor><b>pkgname</b></a></li>
  <li><a id="civ.core.TargetName.name" href="#civ.core.TargetName.name" class=anchor><b>name</b></a></li>
</ul>
<b>Methods</b> <ul>
  <li><a id="TargetName.parse" href="#TargetName.parse" class=anchor><b>fn parse</b></a><span class=code>(T, tgtname)</span></li>
</ul>
<br>
<h4><a id="civ.core.Target" href="#civ.core.Target" class=anchor>Record Target</h4></a>
A build target, the result of compiling a package.
<br>
<b>Fields:</b><ul>
  <li><a id="civ.core.Target.pkgname" href="#civ.core.Target.pkgname" class=anchor><b>pkgname</b></a>
  name of package target is in.</li>
  <li><a id="civ.core.Target.name" href="#civ.core.Target.name" class=anchor><b>name</b></a>
  the name of the target.</li>
  <li><a id="civ.core.Target.kind" href="#civ.core.Target.kind" class=anchor><b>kind</b></a>
  the kind of target: build, test, executable</li>
  <li><a id="civ.core.Target.dir" href="#civ.core.Target.dir" class=anchor><b>dir</b></a>
  directory of src files</li>
  <li><a id="civ.core.Target.src" href="#civ.core.Target.src" class=anchor><b>src</b></a>
  list of input source files (strings).</li>
  <li><a id="civ.core.Target.dep" href="#civ.core.Target.dep" class=anchor><b>dep</b></a>
  list of input Target objects (dependencies).</li>
  <li><a id="civ.core.Target.extra" href="#civ.core.Target.extra" class=anchor><b>extra</b></a>
  arbitrary value, used by run command</li>
  <li><a id="civ.core.Target.api" href="#civ.core.Target.api" class=anchor><b>api</b></a>
  the lang-specific exported import paths.</li>
  <li><a id="civ.core.Target.depIds" href="#civ.core.Target.depIds" class=anchor><b>depIds</b></a>
  list of dependency target ids. Populated for Worker.</li>
  <li><a id="civ.core.Target.out" href="#civ.core.Target.out" class=anchor><b>out</b></a>
  POD table output segregated by language.<ul>
    <li>t: PoD in a k/v table, can be used to configure downstream targets.</li>
    <li>data: list of raw files.</li>
    <li>include: header file paths for native code (C/iA).</li>
    <li>lib: dynamic library files (i.e. libfoo.so)</li>
    <li>bin: executable binaries</li>
    <li>lua: lua files</li>
  </ul></li>
  <li><a id="civ.core.Target.link" href="#civ.core.Target.link" class=anchor><b>link</b></a>
  link outputs from -> to</li>
  <li><a id="civ.core.Target.tag" href="#civ.core.Target.tag" class=anchor><b>tag</b></a>
  arbitrary attributes like test, testonly, etc.</li>
  <li><a id="civ.core.Target.ENV" href="#civ.core.Target.ENV" class=anchor><b>ENV</b></a>
  the environment that scripts run in.</li>
  <li><a id="civ.core.Target.run" href="#civ.core.Target.run" class=anchor><b>run</b></a>
  executable script which performs the operation kind.</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Target.tgtname" href="#Target.tgtname" class=anchor><b>fn:tgtname</b></a><span class=code>()</span></li>
</ul>
<br>
<h4><a id="civ.core.Hub" href="#civ.core.Hub" class=anchor>Record Hub</h4></a>
A hub configuration
<br>
<b>Fields:</b><ul>
  <li><a id="civ.core.Hub.name" href="#civ.core.Hub.name" class=anchor><b>name</b></a> <span class=code>="this"</span>
  the name of the hub</li>
</ul>
<br>
<h4><a id="civ.core.CfgBuilder" href="#civ.core.CfgBuilder" class=anchor>Record CfgBuilder</h4></a>
Cfg.builder settings
<br>
<b>Fields:</b><ul>
  <li><a id="civ.core.CfgBuilder.direct" href="#civ.core.CfgBuilder.direct" class=anchor><b>direct</b></a>
  prefer building directly
  (running build scripts w/ dofile).</li>
</ul>
<br>
<h4><a id="civ.core.Cfg" href="#civ.core.Cfg" class=anchor>Record Cfg</h4></a>
The user configuration, typically at ./.civconfig.lua
<br>
<b>Fields:</b><ul>
  <li><a id="civ.core.Cfg.path" href="#civ.core.Cfg.path" class=anchor><b>path</b></a>
  the path to this config file.</li>
  <li><a id="civ.core.Cfg.host_os" href="#civ.core.Cfg.host_os" class=anchor><b>host_os</b></a>
  the operating system of this computer.'
  Typically equal to civix.OS</li>
  <li><a id="civ.core.Cfg.hubs" href="#civ.core.Cfg.hubs" class=anchor><b>hubs</b></a>
  table of hubname -> /absolute/dir/path</li>
  <li><a id="civ.core.Cfg.buildDir" href="#civ.core.Cfg.buildDir" class=anchor><b>buildDir</b></a>
  directory to put build/test files.</li>
  <li><a id="civ.core.Cfg.installDir" href="#civ.core.Cfg.installDir" class=anchor><b>installDir</b></a>
  directory to install files to.</li>
  <li><a id="civ.core.Cfg.builder" href="#civ.core.Cfg.builder" class=anchor><b>builder</b></a>
  builder settings</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Cfg.load" href="#Cfg.load" class=anchor><b>fn load</b></a><span class=code>(T, path)</span></li>
</ul>
<br>
<h4><a id="civ.core.Civ" href="#civ.core.Civ" class=anchor>Record Civ</h4></a>
Holds top-level data structures and algorithms for
processing civ build graphs (pkgname graphs).
<br>
<b>Fields:</b><ul>
  <li><a id="civ.core.Civ.cfg" href="#civ.core.Civ.cfg" class=anchor><b>cfg</b></a>
  the user config</li>
  <li><a id="civ.core.Civ.thisHub" href="#civ.core.Civ.thisHub" class=anchor><b>thisHub</b></a></li>
  <li><a id="civ.core.Civ.thisPkg" href="#civ.core.Civ.thisPkg" class=anchor><b>thisPkg</b></a></li>
  <li><a id="civ.core.Civ.hubs" href="#civ.core.Civ.hubs" class=anchor><b>hubs</b></a>
  table of hub -> dir (cfg.hubs)</li>
  <li><a id="civ.core.Civ.pkgs" href="#civ.core.Civ.pkgs" class=anchor><b>pkgs</b></a>
  table of pkgname -> pkg</li>
  <li><a id="civ.core.Civ.luk" href="#civ.core.Civ.luk" class=anchor><b>luk</b></a></li>
  <li><a id="civ.core.Civ.cycle" href="#civ.core.Civ.cycle" class=anchor><b>cycle</b></a></li>
  <li><a id="civ.core.Civ.worker" href="#civ.core.Civ.worker" class=anchor><b>worker</b></a>
  direct worker</li>
  <li><a id="civ.core.Civ.ENV" href="#civ.core.Civ.ENV" class=anchor><b>ENV</b></a>
  environment for running workers</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="Civ.load" href="#Civ.load" class=anchor><b>fn load</b></a><span class=code>(T, cfgPath)</span></li>
  <li><a id="Civ.expand" href="#Civ.expand" class=anchor><b>fn:expand</b></a><span class=code>(pat) -&gt; targets</span><br>
  
  Expand a pattern to it's targets.
  This has the side effect of loading all related packages.</li>
  <li><a id="Civ.expandAll" href="#Civ.expandAll" class=anchor><b>fn:expandAll</b></a><span class=code>(tgtpats) -&gt; tgtnames</span><br>
  
  Given a list of hub:foo/.*#.* patterns, expand them.</li>
  <li><a id="Civ.getPkgname" href="#Civ.getPkgname" class=anchor><b>fn:getPkgname</b></a><span class=code>(dep) -&gt; pkgname</span></li>
  <li><a id="Civ.abspath" href="#Civ.abspath" class=anchor><b>fn:abspath</b></a><span class=code>(pkgpath) -&gt; abspath</span><br>
  
  Given a pkg:path/to/file convert to an abspath (used for Luk).</li>
  <li><a id="Civ.pkgDir" href="#Civ.pkgDir" class=anchor><b>fn:pkgDir</b></a><span class=code>(pkgname) -&gt; dir/</span><br>
  
  Get pkgname's full directory.</li>
  <li><a id="Civ.tgtDir" href="#Civ.tgtDir" class=anchor><b>fn:tgtDir</b></a><span class=code>(tgt) -&gt; dir/</span></li>
  <li><a id="Civ.target" href="#Civ.target" class=anchor><b>fn:target</b></a><span class=code>(tgt) -&gt; Target?, errmsg</span></li>
  <li><a id="Civ.loadPkg" href="#Civ.loadPkg" class=anchor><b>fn:loadPkg</b></a><span class=code>(pkgname)</span></li>
  <li><a id="Civ.loadPkgs" href="#Civ.loadPkgs" class=anchor><b>fn:loadPkgs</b></a><span class=code>(pkgnames)</span><br>
  
  Load the pkgs and update self.pkgs with values.</li>
  <li><a id="Civ.targetDepMap" href="#Civ.targetDepMap" class=anchor><b>fn:targetDepMap</b></a><span class=code>(tgts, depMap)</span><br>
  
  recursively find all deps</li>
  <li><a id="Civ.run" href="#Civ.run" class=anchor><b>fn:run</b></a><span class=code>(stage, tgtname, script, ids)</span></li>
  <li><a id="Civ.build" href="#Civ.build" class=anchor><b>fn:build</b></a><span class=code>(tgts) -&gt; ordered, tgtsCache</span><br>
  
  Build the target.</li>
  <li><a id="Civ.test" href="#Civ.test" class=anchor><b>fn:test</b></a><span class=code>(tgtnames, ordered, tgtsCache)</span><br>
  
  Test the targets.</li>
</ul>
<br>
<h4><a id="civ.Worker" href="#civ.Worker" class=anchor>Record civ.Worker</h4></a>
<b>civ.Worker</b> encapsulates a single civ worker, i.e. the
process which actually performs build/test actions.<br>

<br>
<div class=info>If you are just a user of civ this is likely not useful. This library is
useful primarily for those who want to extend civ and/or write their own
build/test macros.</div>
<br>
<b>Fields:</b><ul>
  <li><a id="civ.Worker.ids" href="#civ.Worker.ids" class=anchor><b>ids</b></a>
  the target ids to work on.</li>
  <li><a id="civ.Worker.cfg" href="#civ.Worker.cfg" class=anchor><b>cfg</b></a></li>
  <li><a id="civ.Worker.tgtsDb" href="#civ.Worker.tgtsDb" class=anchor><b>tgtsDb</b></a>
  indexed line-file of targets by id</li>
  <li><a id="civ.Worker.tgtsCache" href="#civ.Worker.tgtsCache" class=anchor><b>tgtsCache</b></a>
  already loaded targets</li>
</ul>
<b>Methods</b> <ul>
  <li><a id="civ.Worker.get" href="#civ.Worker.get" class=anchor><b>fn get</b></a><span class=code>(T, args)</span><br>
  
  Usage: <span class=code>worker = Worker:get()</span></li>
  <li><a id="civ.Worker.target" href="#civ.Worker.target" class=anchor><b>fn:target</b></a><span class=code>(id) -&gt; Target</span></li>
  <li><a id="civ.Worker.copyOut" href="#civ.Worker.copyOut" class=anchor><b>fn:copyOut</b></a><span class=code>(tgt, outKey)</span><br>
  
  Copy output files from <span class=code>tgt.out[outKey]</span>.</li>
  <li><a id="civ.Worker.link" href="#civ.Worker.link" class=anchor><b>fn:link</b></a><span class=code>(tgt)</span></li>
  <li><a id="civ.Worker.set" href="#civ.Worker.set" class=anchor><b>fn:set</b></a><span class=code>()</span><br>
  
  Make self the singleton (future calls to Worker.get will return)</li>
  <li><a id="civ.Worker.close" href="#civ.Worker.close" class=anchor><b>fn:close</b></a><span class=code>()</span><br>
  
  Remove this as singleton.</li>
</ul>
<br>
</div></body>
</html>
