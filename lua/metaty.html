<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
simple but effective Lua type system using metatables
<br>
Metatype is a library and specification for creating performant, documented, and
typo-safe Lua record-types which can be formatted.
<br>
<div class=info> Turn off typo checking by setting the global <span class=code>LUA_OPT=3</span> or higher.</div>
<br>
<div class=code-block>local G = G or _G<br>
--- module documentation<br>
local M = G.mod and mod'myMod' or {} -- (see pkg)<br>
<br>
local mty = require'metaty'<br>
<br>
-- Documentation for Pos (position)<br>
M.Pos = mty'Pos' {<br>
&nbsp; 'x[int]: x coordinate',<br>
&nbsp; 'y[int]: y coordinate', y = 0,<br>
}<br>
<br>
local p1 = Pos{x=4}<br>
local p1 = Pos{x=4, y=3, z=5} -- error if checking turned on
</div>
<br>
The above expands to the following. Note that the "typosafe" elements
are removed when <span class=code>LUA_OPT &gt; 3</span>
<div class=code-block>local M = {}<br>
local metaty = require'metaty'<br>
<br>
local Pos = setmetatable({<br>
&nbsp; __name='Pos',<br>
&nbsp; y = 0,<br>
&nbsp; -- used with metaty.Fmt and help()<br>
&nbsp; __fields={'x', 'y', x='[int]', y='[int]'},<br>
&nbsp; __newindex = metaty.newindex, -- typosafe setting<br>
}, {<br>
&nbsp; __call = function(T, t)<br>
&nbsp; &nbsp; metaty.fieldsCheck(T.__fields, t) -- typosafe constructor<br>
&nbsp; &nbsp; return setmetatable(t, T)<br>
&nbsp; end,<br>
&nbsp; __index = metaty.index, -- typosafe getting<br>
})<br>
Pos.__index = Pos<br>
<br>
-- `mod` gives documentation reflection<br>
PKG_LOCS[M.myFn] &nbsp; &nbsp; &nbsp; &nbsp; = 'path/to/file.lua:123'<br>
PKG_NAMES[M.myFn] &nbsp; &nbsp; &nbsp; &nbsp;= 'mymod.Pos'<br>
PKG_LOOKUP['myMod.Pos'] = M.Pos
</div>
<br>
<h3><a id="metaty-API" href="#metaty-API" class=anchor>API</h3></a> <ul>
  <li><span class=code>ty(v)</span> return the metaty of <span class=code>v</span>. For tables this is <span class=code>getmetatable(v)</span>,
  else it is <span class=code>type(v)</span>.</li>
  <li><span class=code>metaty'name' {'field1[type] documentation', 'field2[type]'}</span>
  creates a documented and typo-safe record type (see examples) <ul>
    <li>the <span class=code>[type]</span> field can also be in the form <span class=code>{type}</span> for a list
    of the type or <span class=code>{string: type}</span> for a map of the type.</li>
    <li><span class=code>@&lt;decimal&gt;</span> (i.e. <span class=code>@2</span>) can be put after the type to specify the
    decimal value to use for the field when de/serializing.
    <br>
    It is recommended that once you assign a field to a decimal value to
    never change it if there is any chance it is stored or being used
    by an RPC service/etc with the previous version.</li>
  </ul></li>
</ul>
<br>
See also: <a href="#Package_fmt">#Package_fmt</a>
<br>
<h3><a id="metaty-why" href="#metaty-why" class=anchor>Why?</h3></a>
<br>
Lua is a fast and fun language. However it often lacks the ability to express
intent when it comes to the structure of data. Also, not only is it not
type-safe but it is also TYPO-unsafe -- small mistakes in the name of a field
can easily result in hard to diagnose bugs, even when they occur in one's
unit-test suite.
<br>
Checking for typos incurrs a small performance cost, so it is disabled by
default. However, it is well-worth the cost in your unit tests.
<br>
<h3><a id="metaty-spec" href="#metaty-spec" class=anchor>Spec</h3></a>
For a type to be considered a "metaty" the only requirement is that it has a
metatable set and that metatable has a <span class=code>__name</span> field.
<br>
The following fields can optionally be set on the metatable: <ul>
  <li><span class=code>__fmt</span>: used with <a href="#Package_fmt">#Package_fmt</a></li>
  <li><span class=code>__fields</span>: should contain a table of <span class=code>fieldName -&gt; fieldtype</span>.
  <span class=code>fieldType</span> can be an arbitrary string and is only for documentation, though
  future libraries/applications (type checkers) may eventually wish to consume
  it. <span class=code>metaty</span> (the library) uses the format <span class=code>"fieldName [user-specified-type]"</span> <ul>
    <li>This is used by formatting libraries when printing the types (so the fields
    are printed in deterministic order).</li>
  </ul></li>
  <li>default values (i.e. <span class=code>y</span> in the example) are assigned directly to the type.
  Documentation formatters may use these to format help messages.</li>
  <li><span class=code>__fieldIds</span>: set using the <span class=code>@&lt;decimal&gt;</span> syntax after the type, used
  for de/serializing.</li>
</ul>
<br>
In addition, there is runtime type specification defined below.
<br>
<h3><a id="metaty-typoe-check" href="#metaty-typoe-check" class=anchor>Runtime typo checking (optional)</h3></a>
<div class=info>Note: Runtime typo checking has a cost and can be disabled with
LUA_OPT=3 or higher.</div>
<br>
You can override the typo-checking behavior of a single type with <div class=code-block>getmetatable(MyType).__call &nbsp;= myConstructor<br>
getmetatable(MyType).__index = myIndex<br>
MyType.__newindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= myNewIndex
</div>
<br>
<h3><a id="lua_opt" href="#lua_opt" class=anchor>LUA_OPT</h3></a>
<span class=code>LUA_OPT</span> is an integer from 0-3 which is intended to have the following
semantic meanings: <ul>
  <li><span class=code>4</span>: may be used for more optimization of certain library functions with
  reduced dynamic abilities, i.e.  logging.</li>
  <li><span class=code>3</span>: optimize out most safety checks and documentation.</li>
  <li><span class=code>2</span>: typosafety or related only, turn off below.</li>
  <li><span class=code>1</span> (default): typosafety and related, plus include docs.</li>
  <li><span class=code>0</span>: no optimizations, turn on anything. May be used as a debug mode or
  similar.</li>
</ul>
<br>
<br>
<h3><a id="metaty" href="#metaty" class=anchor>Mod metaty</h3></a>
metaty: simple but effective Lua type system using metatable
<br>
<b>Functions</b> <ul>
  <li><a id="metaty.isMod" href="#metaty.isMod" class=anchor><b>fn isMod</b></a><span class=code>(t) -&gt; boolean</span></li>
  <li><a id="metaty.setup" href="#metaty.setup" class=anchor><b>fn setup</b></a><span class=code>()</span><br>
  
  Setup lua's global environment to meet metaty protocol.
  
  Currently this only makes non-<span class=code>G</span> global access typosafe (throw error if
  not previously set).</li>
  <li><a id="metaty.isConcrete" href="#metaty.isConcrete" class=anchor><b>fn isConcrete</b></a><span class=code>(v) -&gt; CONCRETE[type(v)]</span></li>
  <li><a id="metaty.isBuiltin" href="#metaty.isBuiltin" class=anchor><b>fn isBuiltin</b></a><span class=code>(obj)</span></li>
  <li><a id="metaty.isEnv" href="#metaty.isEnv" class=anchor><b>fn isEnv</b></a><span class=code>(var)</span><br>
  
  isEnv: returns boolean for below values, else nil</li>
  <li><a id="metaty.isEnvG" href="#metaty.isEnvG" class=anchor><b>fn isEnvG</b></a><span class=code>(var)</span></li>
  <li><a id="metaty.getmethod" href="#metaty.getmethod" class=anchor><b>fn getmethod</b></a><span class=code>(t, method)</span><br>
  
  get method of table if it exists.
  This first looks for the item directly on the table, then the item
  in the table's metatable. It does NOT use the table's normal <span class=code>__index</span>.</li>
  <li><a id="metaty.ty" href="#metaty.ty" class=anchor><b>fn ty</b></a><span class=code>(v) -&gt; type: string or metatable</span><br>
  
  Get the type of the value.</li>
  <li><a id="metaty.tyName" href="#metaty.tyName" class=anchor><b>fn tyName</b></a><span class=code>(T, default) -&gt; string</span><br>
  
  Given a type return it's name</li>
  <li><a id="metaty.name" href="#metaty.name" class=anchor><b>fn name</b></a><span class=code>(o)</span><br>
  
  Given an object (function, table, userdata) return its name.
  return nil if it's not one of the above types</li>
  <li><a id="metaty.callable" href="#metaty.callable" class=anchor><b>fn callable</b></a><span class=code>(obj) -&gt; bool: return if obj is callable</span></li>
  <li><a id="metaty.metaget" href="#metaty.metaget" class=anchor><b>fn metaget</b></a><span class=code>(t, k) -&gt; rawget(getmt(t), k)</span></li>
  <li><a id="metaty.validKey" href="#metaty.validKey" class=anchor><b>fn validKey</b></a><span class=code>(s) -&gt; boolean: s=value is valid syntax</span></li>
  <li><a id="metaty.fninfo" href="#metaty.fninfo" class=anchor><b>fn fninfo</b></a><span class=code>(fn) -&gt; name, loc</span><br>
  
  Extract name,loc from function value.</li>
  <li><a id="metaty.anyinfo" href="#metaty.anyinfo" class=anchor><b>fn anyinfo</b></a><span class=code>(v) -&gt; name, loc</span><br>
  
  Extract name,loc from any value (typically mod/type/function).</li>
  <li><a id="metaty.rawsplit" href="#metaty.rawsplit" class=anchor><b>fn rawsplit</b></a><span class=code>(subj, ctx) -&gt; (state, splitstr)</span><br>
  
  You probably want split instead.
  Usage: <span class=code>for ctx, line in rawsplit, text, {'\n', 1} do</span></li>
  <li><a id="metaty.split" href="#metaty.split" class=anchor><b>fn split</b></a><span class=code>(subj, pat--[[%s+]], index--[[1]]) -&gt; (cxt, str) iter</span><br>
  
  split the subj by pattern. <span class=code>ctx</span> has two keys: <span class=code>si</span> (start index) and
  <span class=code>ei</span> (end index)
  <div class=code-block>for ctx, line in split(text, '\n') do -- split lines<br>
&nbsp; ... do something with line<br>
end
</div></li>
  <li><a id="metaty.fmt" href="#metaty.fmt" class=anchor><b>fn fmt</b></a><span class=code>(self, f)</span><br>
  
  The default __fmt method.</li>
  <li><a id="metaty.tostring" href="#metaty.tostring" class=anchor><b>fn tostring</b></a><span class=code>(self)</span><br>
  
  The default __tostring method.</li>
  <li><a id="metaty.doc" href="#metaty.doc" class=anchor><b>fn doc</b></a><span class=code>(R, d)</span><br>
  
  The default __doc method.
  
  <div class=info>d is of type <span class=code>doc.Documenter</span>.
  Tests are in cmd/doc/test.lua </div></li>
  <li><a id="metaty.nativeEq" href="#metaty.nativeEq" class=anchor><b>fn nativeEq</b></a><span class=code>(a, b) -&gt; a == b</span></li>
  <li><a id="metaty.eqDeep" href="#metaty.eqDeep" class=anchor><b>fn eqDeep</b></a><span class=code>(a, b)</span></li>
  <li><a id="metaty.eq" href="#metaty.eq" class=anchor><b>fn eq</b></a><span class=code>(a, b) -&gt; bool</span><br>
  
  compare tables or anything else</li>
  <li><a id="metaty.indexError" href="#metaty.indexError" class=anchor><b>fn indexError</b></a><span class=code>(R, k, lvl)</span></li>
  <li><a id="metaty.index" href="#metaty.index" class=anchor><b>fn index</b></a><span class=code>(R, k)</span></li>
  <li><a id="metaty.hardIndex" href="#metaty.hardIndex" class=anchor><b>fn hardIndex</b></a><span class=code>(R, k)</span></li>
  <li><a id="metaty.newindex" href="#metaty.newindex" class=anchor><b>fn newindex</b></a><span class=code>(r, k, v)</span></li>
  <li><a id="metaty.hardNewindex" href="#metaty.hardNewindex" class=anchor><b>fn hardNewindex</b></a><span class=code>(r, k, v)</span></li>
  <li><a id="metaty.fieldsCheck" href="#metaty.fieldsCheck" class=anchor><b>fn fieldsCheck</b></a><span class=code>(T, fields, t)</span></li>
  <li><a id="metaty.construct" href="#metaty.construct" class=anchor><b>fn construct</b></a><span class=code>(T, t)</span></li>
  <li><a id="metaty.constructUnchecked" href="#metaty.constructUnchecked" class=anchor><b>fn constructUnchecked</b></a><span class=code>(T, t)</span></li>
  <li><a id="metaty.construct" href="#metaty.construct" class=anchor><b>fn construct</b></a><span class=code>(T, t)</span></li>
  <li><a id="metaty.extendFields" href="#metaty.extendFields" class=anchor><b>fn extendFields</b></a><span class=code>(fields, ids, docs, R)</span></li>
  <li><a id="metaty.namedRecord" href="#metaty.namedRecord" class=anchor><b>fn namedRecord</b></a><span class=code>(name, R, loc)</span></li>
  <li><a id="metaty.record" href="#metaty.record" class=anchor><b>fn record</b></a><span class=code>(name)</span><br>
  
  Start a new record.
  Alternatively, call the metaty module directly.</li>
  <li><a id="metaty.recordMod" href="#metaty.recordMod" class=anchor><b>fn recordMod</b></a><span class=code>(name)</span><br>
  
  Start a new record which acts as a lua module (i.e. the file doesn't use
  <span class=code>metaty.mod</span>)</li>
  <li><a id="metaty.isRecord" href="#metaty.isRecord" class=anchor><b>fn isRecord</b></a><span class=code>(t)</span></li>
  <li><a id="metaty.extend" href="#metaty.extend" class=anchor><b>fn extend</b></a><span class=code>(Type, name, fields)</span><br>
  
  Extend the Type with (optional) new name and (optional) additional fields.</li>
  <li><a id="metaty.extendMod" href="#metaty.extendMod" class=anchor><b>fn extendMod</b></a><span class=code>(T, name, fields)</span><br>
  
  Extend the type with new name and use as a module.</li>
  <li><a id="metaty.enum_tostring" href="#metaty.enum_tostring" class=anchor><b>fn enum_tostring</b></a><span class=code>(E) -&gt; E.__name</span></li>
  <li><a id="metaty.enum_toPod" href="#metaty.enum_toPod" class=anchor><b>fn enum_toPod</b></a><span class=code>(E, pset, e)</span></li>
  <li><a id="metaty.enum_fromPod" href="#metaty.enum_fromPod" class=anchor><b>fn enum_fromPod</b></a><span class=code>(E, pset, e) -&gt; E.name(e)</span></li>
  <li><a id="metaty.enum_partialMatcher" href="#metaty.enum_partialMatcher" class=anchor><b>fn enum_partialMatcher</b></a><span class=code>(E, fnMap)</span></li>
  <li><a id="metaty.enum_matcher" href="#metaty.enum_matcher" class=anchor><b>fn enum_matcher</b></a><span class=code>(E, fnMap)</span></li>
  <li><a id="metaty.namedEnum" href="#metaty.namedEnum" class=anchor><b>fn namedEnum</b></a><span class=code>(ename, nameIds)</span></li>
  <li><a id="metaty.enum" href="#metaty.enum" class=anchor><b>fn enum</b></a><span class=code>(name)</span><br>
  
  Create an enum type which can convert between string and integers.
  
  This "type" is mainly to allow typosafe enums, both when creating the variant
  (i.e. <span class=code>v = MyEnum.VARIANT</span>) and when matching using the <span class=code>matcher</span> method below.
  It also allows using checked enums in <span class=code>ds.pod</span>.
  
  One of the main benefits of using an enum is to ensure that when you are
  matching you don't make a typo mistake (i.e. WOKER instead of WORKER). In
  lua there is no native <span class=code>switch</span> statement (or similar), but table lookup
  on functions can be equally as good -- see the example below.
  
  <h2>Example</h2>
  <div class=code-block>M.Job = enum'Job' {<br>
&nbsp; OWNER &nbsp; = 1,<br>
&nbsp; MANAGER = 2,<br>
&nbsp; COOK &nbsp; &nbsp;= 3,<br>
&nbsp; WAITER &nbsp;= 4,<br>
}<br>
<br>
assert('OWNER', M.Job.OWNER)<br>
<br>
-- either string or id will return string<br>
assert('OWNER', M.Job.name(1))<br>
assert('OWNER', M.Job.name('OWNER'))<br>
<br>
-- either string or id will return id<br>
assert(1, M.Job.id(1))<br>
assert(1, M.Job.id('OWNER'))<br>
<br>
-- create a table that converts a variant (name or id) -&gt; function.<br>
local doJob = M.Job:matcher {<br>
&nbsp; OWNER &nbsp; = function() print'tell them to get to work' end,<br>
&nbsp; MANAGER = function() print'get to work!' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end,<br>
&nbsp; COOK &nbsp; &nbsp;= function() print'order up!' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end,<br>
&nbsp; WAITER &nbsp;= function() print'they want spam and eggs' &nbsp;end,<br>
<br>
&nbsp; -- Removing any of the above will cause an error that not all variants<br>
&nbsp; -- are covered. You can use :partialMatcher if you want to<br>
&nbsp; -- return nil instead.<br>
&nbsp; --<br>
&nbsp; -- Below will cause an error: no variant DISHWASHER<br>
&nbsp; DISHWASHER = function() end<br>
}<br>
<br>
-- call in your own function like:<br>
doJob[job](my, args)
</div></li>
</ul>
<br>
</div></body>
</html>
