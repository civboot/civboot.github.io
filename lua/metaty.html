<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
<h1>metaty: typosafe types using Lua metatables</h1>
Metatype is a library and specification for creating performant, documented,
and typo-safe Lua record-types which can be formatted.

<p>The <a href="#metaty.freeze">#metaty.freeze</a> module allows making types immutable (after calling
<span class=code>freeze</span> on them) and making tables immutable.

<p><div class=info> Turn off typo checking by setting the global <span class=code>LUA_OPT=3</span> or higher.</div>

<p><h2><a id="record" href="#record" class=anchor>Mod and Record</h2></a>
Below is a simple example using <span class=code>metaty.mod</span> to create a module and calling
metatype directly to create a record (the same as <span class=code>metaty.record</span>).

<p><div class=code-block>local mty = require'metaty'<br>
<br>
--- module documentation<br>
local M = mty.mod'myMod'<br>
<br>
--- Documentation for Pos (position)<br>
M.Pos = mty'Pos' {<br>
&nbsp; -- fields are a string of form "name[type]: documentation",<br>
&nbsp; 'x[int]: x coordinate',<br>
&nbsp; 'y[int]: y coordinate', y = 0,<br>
}<br>
<br>
local p1 = Pos{x=4}<br>
local p1 = Pos{x=4, y=3, z=5} -- ERROR: does not have field z
</div>

<p><h2><a id="enum" href="#enum" class=anchor>Enum Type</h2></a>
Metaty also supports creating typosafe enum types with
<span class=code>metaty.enum</span>. An enum is typosafe both when creating the variant
(i.e. <span class=code>v = MyEnum.VARIANT</span>) and when matching using the <span class=code>matcher</span> method
below. It also allows using checked enums in <a href="pod.html">pod.html</a>.

<p>One of the main benefits of using an enum is to ensure that when you are
matching you don't make a typo mistake (i.e. WOKER instead of WORKER). In
lua there is no native <span class=code>switch</span> statement (or similar), but table lookup
on functions can be equally as good -- see the example below.

<p><div class=code-block>M.Job = enum'Job' {<br>
&nbsp; OWNER &nbsp; = 1,<br>
&nbsp; MANAGER = 2,<br>
&nbsp; COOK &nbsp; &nbsp;= 3,<br>
&nbsp; WAITER &nbsp;= 4,<br>
}<br>
<br>
assert('OWNER', M.Job.OWNER)<br>
<br>
-- string or id input returns string<br>
assert('OWNER', M.Job.name(1))<br>
assert('OWNER', M.Job.name('OWNER'))<br>
<br>
-- string or id input returns id<br>
assert(1, M.Job.id(1))<br>
assert(1, M.Job.id('OWNER'))<br>
<br>
-- create a table that converts a variant (name or id) -&gt; function.<br>
local doJob = M.Job:matcher {<br>
&nbsp; OWNER &nbsp; = function() print'tell them to get to work' end,<br>
&nbsp; MANAGER = function() print'get to work!' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end,<br>
&nbsp; COOK &nbsp; &nbsp;= function() print'order up!' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end,<br>
&nbsp; WAITER &nbsp;= function() print'they want spam and eggs' &nbsp;end,<br>
<br>
&nbsp; -- Removing any of the above will cause an error that not all variants<br>
&nbsp; -- are covered. You can use :partialMatcher if you want to<br>
&nbsp; -- return nil instead.<br>
&nbsp; --<br>
&nbsp; -- Below will cause an error: no variant DISHWASHER<br>
&nbsp; DISHWASHER = function() end<br>
}<br>
<br>
-- call in your own function like:<br>
doJob[job](my, args)
</div>

<p><h2><a id="Record_Equivalent" href="#Record_Equivalent" class=anchor>Record Equivalent</h2></a>
The example in <a href="#record">#record</a> expands to the following. Note that the "typosafe"
elements are removed when <span class=code>LUA_OPT &gt; 3</span>.
<div class=code-block>local M = {}<br>
local metaty = require'metaty'<br>
<br>
local Pos = setmetatable({<br>
&nbsp; __name='Pos',<br>
&nbsp; y = 0,<br>
&nbsp; -- used with metaty.Fmt and help()<br>
&nbsp; __fields={'x', 'y', x='[int]', y='[int]'},<br>
&nbsp; __newindex = metaty.newindex, -- typosafe setting<br>
}, {<br>
&nbsp; __call = function(T, t)<br>
&nbsp; &nbsp; metaty.fieldsCheck(T.__fields, t) -- typosafe constructor<br>
&nbsp; &nbsp; return setmetatable(t, T)<br>
&nbsp; end,<br>
&nbsp; __index = metaty.index, -- typosafe getting<br>
})<br>
Pos.__index = Pos<br>
<br>
-- `mod` gives documentation reflection<br>
PKG_LOCS[M.myFn] &nbsp; &nbsp; &nbsp; &nbsp; = 'path/to/file.lua:123'<br>
PKG_NAMES[M.myFn] &nbsp; &nbsp; &nbsp; &nbsp;= 'mymod.Pos'<br>
PKG_LOOKUP['myMod.Pos'] = M.Pos
</div>

<p><h3><a id="metaty-API" href="#metaty-API" class=anchor>API</h3></a> <ul>
  <li><span class=code>ty(v)</span> return the metaty of <span class=code>v</span>. For tables this is <span class=code>getmetatable(v)</span>,
  else it is <span class=code>type(v)</span>.</li>
  <li><span class=code>metaty'name' {'field1[type] documentation', 'field2[type]'}</span>
  creates a documented and typo-safe record type (see examples) <ul>
    <li>the <span class=code>[type]</span> field can also be in the form <span class=code>{type}</span> for a list
    of the type or <span class=code>{string: type}</span> for a map of the type.</li>
    <li><span class=code>@&lt;decimal&gt;</span> (i.e. <span class=code>@2</span>) can be put after the type to specify the
    decimal value to use for the field when de/serializing.
    
    <p>It is recommended that once you assign a field to a decimal value to
    never change it if there is any chance it is stored or being used
    by an RPC service/etc with the previous version.</li>
  </ul></li>
</ul>

<p><h2><a id="metaty-why" href="#metaty-why" class=anchor>Why?</h2></a>

<p>Lua is a fast and fun language. However it often lacks the ability to express
intent when it comes to the structure of data. Also, not only is it not
type-safe but it is also TYPO-unsafe -- small mistakes in the name of a field
can easily result in hard to diagnose bugs, even when they occur in one's
unit-test suite.

<p>Checking for typos incurrs a small performance cost, so it is disabled by
default. However, it is well-worth the cost in your unit tests.

<p><h2><a id="metaty-spec" href="#metaty-spec" class=anchor>Spec</h2></a>
For a type to be considered a "metaty" the only requirement is that it has a
metatable set and that metatable has a <span class=code>__name</span> field.

<p>The following fields can optionally be set on the metatable: <ul>
  <li><span class=code>__fmt</span>: used with <a href="#Package_fmt">#Package_fmt</a></li>
  <li><span class=code>__fields</span>: should contain a table of <span class=code>fieldName -&gt; fieldtype</span>.
  <span class=code>fieldType</span> can be an arbitrary string and is only for documentation, though
  future libraries/applications (type checkers) may eventually wish to consume
  it. <span class=code>metaty</span> (the library) uses the format <span class=code>"fieldName [user-specified-type]"</span> <ul>
    <li>This is used by formatting libraries when printing the types (so the fields
    are printed in deterministic order).</li>
  </ul></li>
  <li>default values (i.e. <span class=code>y</span> in the example) are assigned directly to the type.
  Documentation formatters may use these to format help messages.</li>
  <li><span class=code>__fieldIds</span>: set using the <span class=code>@&lt;decimal&gt;</span> syntax after the type, used
  for de/serializing.</li>
</ul>

<p>In addition, there is runtime type specification defined below.

<p><h2><a id="metaty-typoe-check" href="#metaty-typoe-check" class=anchor>Runtime typo checking (optional)</h2></a>
<div class=info>Note: Runtime typo checking has a cost and can be disabled with
LUA_OPT=3 or higher.</div>

<p>You can override the typo-checking behavior of a single type with <div class=code-block>getmetatable(MyType).__call &nbsp;= myConstructor<br>
getmetatable(MyType).__index = myIndex<br>
MyType.__newindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= myNewIndex
</div>

<p><h2><a id="lua_opt" href="#lua_opt" class=anchor>LUA_OPT</h2></a>
<span class=code>LUA_OPT</span> is an integer from 0-3 which is intended to have the following
semantic meanings: <ul>
  <li><span class=code>4</span>: may be used for more optimization of certain library functions with
  reduced dynamic abilities, i.e.  logging.</li>
  <li><span class=code>3</span>: optimize out most safety checks and documentation.</li>
  <li><span class=code>2</span>: typosafety or related only, turn off below.</li>
  <li><span class=code>1</span> (default): typosafety and related, plus include docs.</li>
  <li><span class=code>0</span>: no optimizations, turn on anything. May be used as a debug mode or
  similar.</li>
</ul>

<p>
<p><h3><a id="metaty" href="#metaty" class=anchor>Mod metaty</h3></a>
metaty: simple but effective Lua type system using metatable

<p><b>Functions</b> <ul>
  <li><a id="metaty.isMod" href="#metaty.isMod" class=anchor><b>fn isMod</b></a><span class=code>(t) -&gt; boolean</span><br>
  
  Return whether the value is a module.</li>
  <li><a id="metaty.setup" href="#metaty.setup" class=anchor><b>fn setup</b></a><span class=code>()</span><br>
  
  Setup lua's global environment to meet metaty protocol.
  
  <p>Currently this only makes non-<span class=code>G</span> global access typosafe (throw error if
  not previously set).</li>
  <li><a id="metaty.isConcrete" href="#metaty.isConcrete" class=anchor><b>fn isConcrete</b></a><span class=code>(v)</span><br>
  
  Return whether v is a nil, boolean, number or string.</li>
  <li><a id="metaty.isBuiltin" href="#metaty.isBuiltin" class=anchor><b>fn isBuiltin</b></a><span class=code>(obj)</span><br>
  
  Return whether v is concrete or a table with no metatable.</li>
  <li><a id="metaty.isEnv" href="#metaty.isEnv" class=anchor><b>fn isEnv</b></a><span class=code>(var)</span><br>
  
  Given a string return whether os.getenv returns 'true' or '1'.</li>
  <li><a id="metaty.isEnvG" href="#metaty.isEnvG" class=anchor><b>fn isEnvG</b></a><span class=code>(var)</span><br>
  
  Same as isEnv but first checks globals.</li>
  <li><a id="metaty.getmethod" href="#metaty.getmethod" class=anchor><b>fn getmethod</b></a><span class=code>(t, method)</span><br>
  
  Get method of table if it exists.<br>
  
  This first looks for the item directly on the table, then the item in the
  table's metatable. It does NOT use the table's normal <span class=code>__index</span>.</li>
  <li><a id="metaty.ty" href="#metaty.ty" class=anchor><b>fn ty</b></a><span class=code>(v) -&gt; type</span><br>
  
  Get the type of the value which is either the values metatable or the
  string result of <span class=code>type(v)</span>.</li>
  <li><a id="metaty.tyName" href="#metaty.tyName" class=anchor><b>fn tyName</b></a><span class=code>(T, default) -&gt; string</span><br>
  
  Given a type return it's name.</li>
  <li><a id="metaty.name" href="#metaty.name" class=anchor><b>fn name</b></a><span class=code>(o)</span><br>
  
  Given an object (function, table, userdata) return its name.
  Return it's string type if it's not one of the above types.</li>
  <li><a id="metaty.callable" href="#metaty.callable" class=anchor><b>fn callable</b></a><span class=code>(obj) -&gt; bool</span><br>
  
  Return whether obj is callable (function or has <span class=code>mt.__call</span>).</li>
  <li><a id="metaty.validKey" href="#metaty.validKey" class=anchor><b>fn validKey</b></a><span class=code>(s) -&gt; boolean</span><br>
  
  Return whether s can be used directly as a key
  in syntax.</li>
  <li><a id="metaty.fninfo" href="#metaty.fninfo" class=anchor><b>fn fninfo</b></a><span class=code>(fn) -&gt; name, loc</span><br>
  
  Extract name,loc from function value.</li>
  <li><a id="metaty.anyinfo" href="#metaty.anyinfo" class=anchor><b>fn anyinfo</b></a><span class=code>(v) -&gt; name, loc</span><br>
  
  Extract name,loc from any value (typically mod/type/function).</li>
  <li><a id="metaty.rawsplit" href="#metaty.rawsplit" class=anchor><b>fn rawsplit</b></a><span class=code>(subj, ctx) -&gt; (state, splitstr)</span><br>
  
  You probably want split instead.
  Usage: <span class=code>for ctx, line in rawsplit, text, {'\n', 1} do</span></li>
  <li><a id="metaty.split" href="#metaty.split" class=anchor><b>fn split</b></a><span class=code>(subj, pat--[[%s+]], index--[[1]]) -&gt; (cxt, str) iter</span><br>
  
  split the subj by pattern. <span class=code>ctx</span> has two keys: <span class=code>si</span> (start index) and
  <span class=code>ei</span> (end index)
  <div class=code-block>for ctx, line in split(text, '\n') do -- split lines<br>
&nbsp; ... do something with line<br>
end
</div></li>
  <li><a id="metaty.copyMethod" href="#metaty.copyMethod" class=anchor><b>fn copyMethod</b></a><span class=code>(self)</span><br>
  
  The <span class=code>__copy</span> method.</li>
  <li><a id="metaty.fmt" href="#metaty.fmt" class=anchor><b>fn fmt</b></a><span class=code>(self, f)</span><br>
  
  The default __fmt method.</li>
  <li><a id="metaty.tostring" href="#metaty.tostring" class=anchor><b>fn tostring</b></a><span class=code>(self)</span><br>
  
  The default __tostring method.</li>
  <li><a id="metaty.doc" href="#metaty.doc" class=anchor><b>fn doc</b></a><span class=code>(R, d)</span><br>
  
  The default __doc method.
  
  <p><div class=info>d is of type <span class=code>doc.Documenter</span>.
  Tests are in cmd/doc/test.lua </div></li>
  <li><a id="metaty.eq" href="#metaty.eq" class=anchor><b>fn eq</b></a><span class=code>(a, b) -&gt; bool</span><br>
  
  Compare two values (any values) for equality. This will
  recursively check tables for equality.</li>
  <li><a id="metaty.indexError" href="#metaty.indexError" class=anchor><b>fn indexError</b></a><span class=code>(R, k, lvl)</span><br>
  
  Throws a formatted index error when called.</li>
  <li><a id="metaty.index" href="#metaty.index" class=anchor><b>fn index</b></a><span class=code>(R, k)</span><br>
  
  Usage: <span class=code>getmetable(MyType).__index = mty.index</span><br>
  
  Allows integers to be insert into your value. This is the default __index.</li>
  <li><a id="metaty.hardIndex" href="#metaty.hardIndex" class=anchor><b>fn hardIndex</b></a><span class=code>(R, k)</span><br>
  
  Usage: <span class=code>getmetable(MyType).__index = mty.index</span><br>
  
  Allows nothing except your type's fields to be insert into
  your value.</li>
  <li><a id="metaty.newindex" href="#metaty.newindex" class=anchor><b>fn newindex</b></a><span class=code>(r, k, v)</span><br>
  
  Usage: <span class=code>MyType.__newindex = mty.newindex</span><br>
  
  (record default) this allows non-string keys to always be insert.</li>
  <li><a id="metaty.hardNewindex" href="#metaty.hardNewindex" class=anchor><b>fn hardNewindex</b></a><span class=code>(r, k, v)</span><br>
  
  Usage: <span class=code>MyType.__newindex = mty.hardNewindex</span><br>
  
  This allows only registered fields to be insert.</li>
  <li><a id="metaty.construct" href="#metaty.construct" class=anchor><b>fn construct</b></a><span class=code>(T, t)</span><br>
  
  Usage: <span class=code>getmetatable(MyType).__call = mty.constructChecked</span>
  
  <p>Check type with field typochecking. This is the default when
  <span class=code>LUA_OPT &lt;= 2</span></li>
  <li><a id="metaty.constructUnchecked" href="#metaty.constructUnchecked" class=anchor><b>fn constructUnchecked</b></a><span class=code>(T, t)</span><br>
  
  Usage: <span class=code>getmetatable(MyType).__call = mty.constructUnchecked</span>
  
  <p>Check type with field typochecking. This is the default when
  <span class=code>LUA_OPT &gt;= 3</span>.</li>
  <li><a id="metaty.construct" href="#metaty.construct" class=anchor><b>fn construct</b></a><span class=code>(T, t)</span><br>
  
  Usage: <span class=code>getmetatable(MyType).__call = mty.constructChecked</span>
  
  <p>Check type with field typochecking. This is the default when
  <span class=code>LUA_OPT &lt;= 2</span></li>
  <li><a id="metaty.record" href="#metaty.record" class=anchor><b>fn record</b></a><span class=code>(name)</span><br>
  
  Usage: <span class=code>record'name'{ 'field [type]: documentation' }</span>
  
  <p>Start a new record. See module documentation for details.</li>
  <li><a id="metaty.recordMod" href="#metaty.recordMod" class=anchor><b>fn recordMod</b></a><span class=code>(name)</span><br>
  
  Start a new record which acts as a lua module (i.e. the file returns it).</li>
  <li><a id="metaty.isRecord" href="#metaty.isRecord" class=anchor><b>fn isRecord</b></a><span class=code>(t)</span><br>
  
  Return true if <span class=code>t</span> is a record value.</li>
  <li><a id="metaty.extend" href="#metaty.extend" class=anchor><b>fn extend</b></a><span class=code>(Type, name, fields)</span><br>
  
  Usage: <span class=code>mty.extend(MyBase, 'NewName', {...new fields...})</span>
  
  <p>Extend the Type with (optional) new name and (optional) additional fields.</li>
  <li><a id="metaty.extendMod" href="#metaty.extendMod" class=anchor><b>fn extendMod</b></a><span class=code>(T, name, fields)</span><br>
  
  Extend the type with new name and use as a module.</li>
  <li><a id="metaty.enum" href="#metaty.enum" class=anchor><b>fn enum</b></a><span class=code>(name)</span><br>
  
  Usage: <span class=code>mty.enum'name' { A = 1, B = 2, ... }</span><br>
  
  Create an enum type. See module documentation.</li>
  <li><a id="metaty.want" href="#metaty.want" class=anchor><b>fn want</b></a><span class=code>(mod) -&gt; module?</span><br>
  
  like require but returns nil if not found.</li>
  <li><a id="metaty.from" href="#metaty.from" class=anchor><b>fn from</b></a><span class=code>(a, b)</span><br>
  
  Usage: <span class=code>local bar, baz = mty.from'foo bar,baz'</span><br>
  
  Usage: <span class=code>local sfmt, srep = mty.from(string, 'format,rep')</span><br>
  
  Shortcut for: <div class=code-block>&nbsp; local foo = require'foo'<br>
&nbsp; local bar, baz = foo.bar, foo.baz<br>
&nbsp; 
</div></li>
</ul>

<p><h3><a id="metaty.freeze" href="#metaty.freeze" class=anchor>Mod metaty.freeze</h3></a>
Usage: <span class=code>freeze.freezy(MyType)</span> to make MyType freezable, see

<p><a href="#metaty.freeze.freezy">#metaty.freeze.freezy</a>.

<p>
<p>
<p>Call usage: <span class=code>freeze(v)</span><br>


<p>When called: freezes the value, see <a href="#metaty.freeze.freeze">#metaty.freeze.freeze</a>.

<p>
<p><b>Types: </b><a href="#metaty.freeze.frozen">frozen</a> 

<p><b>Functions</b> <ul>
  <li><a id="metaty.freeze.frozenNext" href="#metaty.freeze.frozenNext" class=anchor><b>fn frozenNext</b></a><span class=code>(FROZEN[f], k)</span></li>
  <li><a id="metaty.freeze.freeze" href="#metaty.freeze.freeze" class=anchor><b>fn freeze</b></a><span class=code>(v)</span><br>
  
  Freeze value, making it immutable.
  
  <p>Implementation: If <span class=code>v</span> is a table, the table's actual values are moved
  to a table in <span class=code>freeze.FROZEN</span>, which is where they are retrieved.
  <span class=code>__index</span>, etc are frozen to give an immutable "view" into this table.
  
  <p>If <span class=code>v</span> is userdata, <span class=code>:freeze()</span> is called on it.
  
  <p>Concrete lua values are already immutable. Functions are considered
  already frozen, it is the author's responsibility to ensure functions don't
  mutate state.</li>
  <li><a id="metaty.freeze.freezy" href="#metaty.freeze.freezy" class=anchor><b>fn freezy</b></a><span class=code>(R)</span><br>
  
  Usage: <span class=code>M.MyType = freeze.freezy(mty'MyType' { ... })</span><br>
  
  Make the type <span class=code>:freeze()</span>-able, after which it will be immutable.
  
  <p>This has a performance cost both before and after the value is frozen.
  
  <p><div class=info>Through three cheese trees three free fleas flew.<br>
  
  While these fleas flew, freezy breeze blew.<br>
  
  Freezy breeze made these three trees freeze.<br>
  
  Freezy trees made these trees' cheese freeze.<br>
  
  That's what made these three free fleas sneeze.<br>
  
  - Dr Seuss, "Fox in Socks"
  </div></li>
  <li><a id="metaty.freeze.isFrozen" href="#metaty.freeze.isFrozen" class=anchor><b>fn isFrozen</b></a><span class=code>(v)</span><br>
  
  Return whether v is immutable.</li>
  <li><a id="metaty.freeze.forceset" href="#metaty.freeze.forceset" class=anchor><b>fn forceset</b></a><span class=code>(t, k, v)</span><br>
  
  Force set the value, even on a frozen type. Obviously,
  this should be used with caution.</li>
</ul>

<p><h4><a id="metaty.freeze.frozen" href="#metaty.freeze.frozen" class=anchor>Record frozen</h4></a>
A "plain old table" that has been frozen (made immutable).

<p>
<p>
</div></body>
</html>
