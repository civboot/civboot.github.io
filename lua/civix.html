<head>
  <meta charset="utf-8">
  <title>Civboot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
</head>
<nav>
  <ul>
    <a href="../index.html"   class="nav"             >civ/</a>
    <a href="index.html"      class="nav nav-selected">lua/</a>
  </ul>
</nav>

<!DOCTYPE html>
<html>
<body><div class=doc>
Civboot's unix system library
<p>
Civix contains standard unix functions that exist in most language's "sys"
library such as <span class=code>sleep</span>, <span class=code>epoch</span> etc. It also contains a powerful <span class=code>Sh{}</span> type
and convieience <span class=code>sh()</span> function for executing system shell commands, either
synchronously or asynchronously using the LAP protocol (see <a href="#Package_lap">#Package_lap</a>.
<p>
<div class=code-block>$ lua<br>
&gt; sh = require'civix'.sh<br>
&gt; print(sh'ls some/path')<br>
&gt; -- cat /var/log/syslog | grep "netgroup: version"<br>
&gt; out = sh{stdin=io.open'/var/log/syslog', 'grep', 'netgroup: version'}<br>
&gt; for line in require'ds'.lines(out) do ... something per line ... end
</div>
<p>
<div class=info>Civix depends on the <a href="#Package_fd">#Package_fd</a> library for async file descriptors and
other filedescriptor functionality.</div>
<p>
<h1><a id=""civix"" href="#"civix"">Mod civix</h1></a>
civix: unix-like OS utilities.
<p>
<b>Types</b> <ul>
  <li><b>civix.B</b></li>
  <li><b>civix.Walk</b></li>
  <li><b>civix.Sh</b></li>
  <li><b>civix.ShFin</b></li>
</ul>
<p>
<b>Functions</b> <ul>
  <li><span class=code>mkdir(path)</span></li>
  <li><span class=code>dir(path)</span></li>
  <li><span class=code>rmdir(path)</span></li>
  <li><span class=code>exists(path)</span></li>
  <li><span class=code>pathtype(path)</span></li>
  <li><span class=code>rm(path) -&gt; nil</span>
  remove file.</li>
  <li><span class=code>statModifiedEq(fs1, fs2) -&gt; boolean</span>
  return whether two Stat's have equal modification times</li>
  <li><span class=code>stat(v) -&gt; Stat?, errmsg?</span>
  Given a path|File|Stat return a Stat</li>
  <li><span class=code>modifiedEq(a, b)</span>
  return whether two path|File|Stat have equal modification times</li>
  <li><span class=code>getpagesize() -&gt; 4096</span></li>
  <li><span class=code>ls(dir) -&gt; list[str]</span>
  Return the entries in a dir as a list.
  They are sorted to put the directories first.</li>
  <li><span class=code>mv(old, new)</span>
  Move path from old -> new, throwing an error on failure.</li>
  <li><span class=code>fdWrite(to, from, sz--[[=BLOCK_SZ]]) -&gt; (to, from)</span>
  Read data from fd <span class=code>from</span> and write to fd <span class=code>to</span>, then flush.</li>
  <li><span class=code>cp(from, to)</span>
  copy data from <span class=code>from</span> to <span class=code>to</span>. Their types can be either
  a string (path) or a file descriptor.</li>
  <li><span class=code>swap(a, b, ext)</span>
  swap paths a <-> b</li>
  <li><span class=code>setModified(f, sec, nsec) -&gt; ok, errmsg?</span>
  set the modified time of the path|file</li>
  <li><span class=code>quote(str)</span>
  quote the str if it's possible</li>
  <li><span class=code>sleep(d) -&gt; nil</span>
  Sleep for the specified duration</li>
  <li><span class=code>epoch() -&gt; ds.Epoch(lib.epoch())</span>
  Return the Epoch/Mono time
  Time according to realtime clock</li>
  <li><span class=code>mono() -&gt; ds.Duration(lib.mono())</span>
  Duration according to monotomically incrementing clock.</li>
  <li><span class=code>monoSec() -&gt; M.mono():asSeconds()</span></li>
  <li><span class=code>pathEq(path1, path2)</span>
  return if the contents of the two paths are equal.
  If both are directories return true (do not recurse).
  If both don't exist return true</li>
  <li><span class=code>isFile(path) -&gt; M.pathtype(path) == 'file'</span></li>
  <li><span class=code>isDir(path) -&gt; M.pathtype(path) == 'dir'</span></li>
  <li><span class=code>walk(paths, ftypeFns, maxDepth)</span>
  TODO: remove this, use Walk instead.
  walk the paths up to depth, calling <span class=code>ftypeFns[ftype]</span> for
  each item encountered.
  
  If depth is nil/false then the depth is infinite.
  
  ftypeFns must be a table of ftypes (file, dir) and: <ul>
    <li>default: called as fallback (if missing ftype key)</li>
    <li>error: called if determining the type caused an error,
    typically due to the file not existing.
    the call is: error(path, errstr)</li>
    <li>dirDone: called AFTER the directory has been walked</li>
  </ul>
  
  The Fn signatures are: (path, ftype) -> stopWalk
  If either return true then the walk is ended immediately
  If dirFn returns 'skip' then the directory is skipped</li>
  <li><span class=code>cpRecursive(from, to, except)</span>
  recursively copy <span class=code>from/</span> to new <span class=code>to/</span> directory.</li>
  <li><span class=code>rmRecursive(path)</span></li>
  <li><span class=code>mkDirs(path)</span></li>
  <li><span class=code>mkDir(path, parents)</span></li>
  <li><span class=code>forceCp(from, to)</span>
  copy <span class=code>from</span> to <span class=code>to</span>, creating the directory structure if necessary.</li>
  <li><span class=code>forceWrite(path, text)</span>
  write <span class=code>text</span> to <span class=code>path</span>, creating the directory structure if necessary.</li>
  <li><span class=code>mkTree(dir, tree, parents)</span>
  mkTree(tree) builds a tree of files and dirs at `dir` <ul>
    <li>Dirs  are tables.</li>
    <li>Files are string or fd -- which are read+closed.</li>
  </ul>
  Example: <div class=code-block>&nbsp; tree = {<br>
&nbsp; &nbsp; a = {<br>
&nbsp; &nbsp; &nbsp; ['a1.txt'] = 'stuff in a1.txt',<br>
&nbsp; &nbsp; &nbsp; ['a2.txt'] = 'stuff in a.txt',<br>
&nbsp; &nbsp; &nbsp; a3 = {<br>
&nbsp; &nbsp; &nbsp; &nbsp; ['a4.txt'] = io.open'some/file.txt',<br>
&nbsp; &nbsp; &nbsp; }<br>
&nbsp; &nbsp; }<br>
&nbsp; }<br>
&nbsp; 
</div>
  
  Builds a tree like <div class=code-block>&nbsp; a/a1.txt &nbsp; &nbsp;# content: stuff in a1.txt<br>
&nbsp; a/a2.txt &nbsp; &nbsp;# content: stuff in a2.txt<br>
&nbsp; a/a3/a4.txt # content: stuff in a3.txt<br>
&nbsp; 
</div></li>
  <li><span class=code>Lap()</span></li>
  <li><span class=code>sh(M,'sh') -&gt; out, err, Sh</span>
  Execute the command in another process via execvp (system shell). Throws an
  error if the command fails.
  
  if cmd is a table, the following keys are treated as special. If you need any
  of these then you must use M.Sh directly (recommendation: use Plumb) <ul>
    <li><span class=code>stdin[string|file]</span> the process's stdin. If string it will be sent to stdin.</li>
    <li><span class=code>stdout[file]</span> the process's stdout. out will be nil if this is set</li>
    <li><span class=code>stderr[file]</span> the process's stderr (default=io.stderr)</li>
    <li><span class=code>ENV [table]</span> the process's environment.</li>
    <li><span class=code>CWD [table]</span> the process's current directory.</li>
    <li><span class=code>rc [bool]</span> if true allow non-zero return codes (else throw error).
    You can get the rc with <span class=code>sh:rc()</span> (method on 3rd return argument).</li>
  </ul>
  
  Note: use <span class=code>Plumb{...}:run()</span> if you want to pipe multiple shells together.
  <div class=table><table>
    <tr>
      <th>Command                               Bash</th>
    </tr>
    <tr>
      <td><span class=code>sh'ls foo/bar'</span></td>
      <td><span class=code>ls foo/bar</span></td>
    </tr>
    <tr>
      <td><span class=code>sh{'ls', 'foo/bar', 'dir w spc/'}</span></td>
      <td><span class=code>ls foo/bar "dir w spc/"</span></td>
    </tr>
    <tr>
      <td><span class=code>sh{stdin='sent to stdin', 'cat'}</span></td>
      <td><span class=code>echo "sent to stdin" | cat</span></td>
    </tr>
  </table></div></li>
  <li><span class=code>isRoot() -&gt; os.getenv'EUID' == '0'</span></li>
</ul>
<p>
<h2><a id=""civix.B"" href="#"civix.B"">Mod civix.B</h2></a>
Several (but not all) functions in this module are used for civ.lua.
However, native modules especially cannot be loaded before the
bulid system is bootstrapped (at least not easily), so there are
a few of these checks for NOLIB in this library which will use
civix.B (bootstrap) instead in that case.
<p>
Clients should typically not use civix.B.
<p>
<b>Functions</b> <ul>
  <li><span class=code>sh(cmd) -&gt; stdout, stderr, fakeSh</span></li>
  <li><span class=code>mkdir(dir)</span></li>
  <li><span class=code>rmdir(dir)</span></li>
  <li><span class=code>dir(dir) -&gt; iter[entry]</span></li>
  <li><span class=code>exists(path) -&gt; bool</span></li>
  <li><span class=code>pathtype(path)</span></li>
</ul>
<p>
<h2><a id=""civix.Walk"" href="#"civix.Walk"">Record Walk</h2></a>
<ul>
  <li><b>maxDepth</b> :
  maximum depth to walk (default=infinite)</li>
  <li><b>pi</b> :
  the current (root) path index being walked</li>
</ul>
Walk the directory tree as a iterator of <span class=code>path, ftype</span>. Can walk either a
single path <span class=code>Walk'path/'</span> or a list of paths <span class=code>Walk{'a/', 'b.txt'}</span>. <ul>
  <li>Note: all <span class=code>ftype=='dir'</span> paths end in <span class=code>/</span>.</li>
  <li>Warning: you may want to handle <span class=code>ftype=='error'</span></li>
</ul>
<p>
<h2><a id=""civix.Sh"" href="#"civix.Sh"">Record Sh</h2></a>
<ul>
  <li><b>args</b> :
  arguments to pass to shell</li>
  <li><b>stdin</b> :
  shell's stdin to send  (default=empty)</li>
  <li><b>stdout</b> :
  shell's stdout              (default=empty)</li>
  <li><b>stderr</b> :
  shell's stderr              (default=empty)</li>
  <li><b>env</b> :
  shell's environment {'FOO=bar', ...}</li>
  <li><b>cwd</b> :
  current working directory</li>
</ul>
Start args on the shell
<div class=info>Suggestion: use civix.sh instead.</div>
<p>
<span class=code>Sh:start()</span> kicks off a subprocess which start the shell using the fds
you pass in or creating them if you set them to true. Created file
descriptors will be stored in the associated name.
<p>
<div class=info>Why? This means that <span class=code>:close()</span> will only close filedescriptors created
by the shell itself, and you won't accidentially close
io.stdout/etc.</div>
<p>
Examples (see civix.sh for more examples): <div class=table><table>
  <tr>
    <th>Lua</th>
    <th>Bash</th>
  </tr>
  <tr>
    <td><span class=code>Sh({'ls', 'foo/bar'}, {stdout=io.stdout}):start()</span></td>
    <td><span class=code>ls foo/bar</span></td>
  </tr>
  <tr>
    <td><span class=code>v = Sh{'ls foo/bar', stdout=true}:start():read'a'</span></td>
    <td><span class=code>v=$(ls foo/bar)</span></td>
  </tr>
</table></div>
<p>
<h2><a id=""civix.ShFin"" href="#"civix.ShFin"">Record ShFin</h2></a>
<ul>
  <li><b>stdin</b> </li>
  <li><b>stdout</b> </li>
  <li><b>stderr</b> </li>
  <li><b>input</b> :
  write to then close stdin (either self's or shell's)</li>
</ul>
<p>
<h1><a id=""civix.testing"" href="#"civix.testing"">Mod civix.testing</h1></a>
test runners and helpers for civix
<p>
<b>Functions</b> <ul>
  <li><span class=code>runAsyncTest(fn)</span>
  Typically an entire test file is wrapped in a function,
  then passed to this -- which runs all tests sequentially
  inside the lap environment.
  
  <div class=info>This does not print test names/etc. Use civtest or
  equivalent for that.
  </div></li>
</ul>
<p>
</div></body>
</html>
